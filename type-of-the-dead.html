<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Type of the Dead</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: monospace;
  }
  #gameContainer {
    position: relative;
    border: 3px solid #00ff41;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
    border-radius: 8px;
    outline: none;
  }
  canvas { display: block; border-radius: 5px; }
</style>
</head>
<body>
<div id="gameContainer" tabindex="0">
  <canvas id="gameCanvas"></canvas>
</div>

<script>
// ============================================================
// TYPE OF THE DEAD - Browser-Based Typing Game
// Single standalone file - no dependencies
// ============================================================

(function() {
'use strict';

const CANVAS_W = 900;
const CANVAS_H = 650;
const GROUND_Y = CANVAS_H - 100;
const PLAYER_X = CANVAS_W / 2;
const PLAYER_Y = CANVAS_H - 80;

// --- Word Lists ---
const WORDS = {
  easy: [
    'cat','dog','run','jump','fast','slow','fire','dead','bite','dark',
    'bone','gore','fear','hand','head','kill','limb','moon','nail','pain',
    'rot','skin','tomb','vein','walk','yell','claw','doom','dusk','fade',
    'grim','howl','hunt','lurk','maul','ooze','prey','scar','wail','wake',
    'axe','bat','cry','dig','eat','fog','gut','hex','ink','jaw',
    'ash','ban','cap','den','elm','foe','gas','hog','ice','jab',
    'keg','lab','map','net','oak','pad','rag','sap','tar','urn'
  ],
  medium: [
    'zombie','typing','undead','blood','coffin','corpse','ghoul','grave',
    'horror','infect','killer','mortal','plague','scream','shadow','terror',
    'venom','wicked','attack','brain','crypt','decay','eerie','flesh',
    'haunt','impale','jungle','kidnap','legion','mayhem','nectar','occult',
    'python','quarry','ravage','savage','tangle','unholy','vandal','wraith',
    'ambush','blight','cackle','dagger','escape','fright','goblin','hunger',
    'impact','jackal','mortar','devour','fiend','mutant','sinister','demise'
  ],
  hard: [
    'apocalypse','resurrect','nightmare','graveyard','infection','slaughter',
    'decompose','monstrous','bloodbath','cannibal','cremation','disturbing',
    'exorcism','grotesque','headstone','labyrinth','mortician','nocturnal',
    'paranormal','quarantine','reanimated','sacrifice','tormented','underbelly',
    'vengeance','wasteland','adrenaline','barricade','contagion','damnation',
    'eliminate','fortified','guillotine','hallucinate','infestation',
    'juggernaut','kettledrum','laceration','malevolent','necromancer',
    'obliterate','pandemonium','relentless','suffocate','trepidation',
    'unforgiving','vulnerable','wanderlust','xenophobia','yellowjacket'
  ],
  extreme: [
    'electromagnetic','hyperventilating','uncomfortable','psychologically',
    'interconnected','cardiovascular','groundbreaking','unprecedented',
    'counterproductive','distinguishable','overwhelming','comprehensive',
    'claustrophobic','uncontrollable','extraordinaire','disproportionate',
    'temperamental','incomprehensible','overexaggerate','sentimentality',
    'biodegradable','characterization','communication','accountability',
    'infrastructure','recommendation','organizational','environmental',
    'pharmaceutical','simultaneously','procrastination','rehabilitation',
    'misunderstanding','acknowledgement','conceptualization','experimentation',
    'inconsequential','revolutionizing','compartmentalize','extraordinarily'
  ],
  nightmare: [
    'deoxyribonucleic','internationalization','counterrevolutionary',
    'disproportionately','incomprehensibility','electroencephalograph',
    'unconstitutionality','compartmentalization','oversimplification',
    'underrepresentation','characteristically','disadvantageously',
    'indistinguishable','microelectronics','multidimensional',
    'nonrepresentational','overcommunicating','straightforwardness',
    'uncharacteristically','weatherproofing','mischaracterization',
    'overcompensating','underprivileged','uncompromisingly',
    'intercontinental','photosynthesizing','telecommunications',
    'disenfranchisement','neuropsychological','administratively'
  ],
  miniboss: [
    'hemorrhaging viscera','decaying flesh wound','putrid reanimation',
    'necrotic contamination','grotesque abomination','shambling corpsewalker',
    'festering plague carrier','ravenous brain eater','unholy resurrection',
    'cadaverous nightmare','infectious outbreak zone','decomposing horde leader',
    'malevolent death bringer','parasitic infestation','skeletal juggernaut',
    'corrupted gravedigger','venomous plague doctor','spectral executioner',
    'carnivorous stalker','relentless bone crusher'
  ]
};

const BOSS_TEXT = {
  easy: [
    'the dead walk among us now',
    'run before they find you here',
    'we must escape this cursed place',
    'the graveyard has opened its gates',
    'no one survives the zombie horde',
    'darkness falls and the dead rise'
  ],
  normal: [
    'the zombie horde approaches from every dark corner of this forsaken city',
    'we barricaded the doors but they keep breaking through the windows',
    'only the fastest typists will survive the coming apocalypse tonight',
    'the infection spreads rapidly and there is no known cure for it',
    'abandoned buildings provide shelter but the dead are always hunting',
    'every keystroke fires a bullet into the advancing wall of undead'
  ],
  hard: [
    'the abandoned hospital was overrun within hours as the infected poured through every entrance and stairwell relentlessly',
    'survivors gathered at the rooftop hoping for rescue but the helicopter never arrived and supplies were running dangerously low',
    'the scientist claimed the virus was engineered in a laboratory but nobody believed her until it was far too late to stop it',
    'gunfire echoed through the empty streets as the last remaining soldiers fought desperately against the unstoppable swarm of corpses'
  ],
  extreme: [
    'the world as we knew it ended on a tuesday afternoon when the first reports of the dead rising came through on every news channel. within seventy two hours civilization had collapsed entirely and the streets belonged to the undead.',
    'deep beneath the research facility the containment protocols had failed catastrophically. the experimental pathogen designated omega seven had breached every quarantine zone and was now airborne spreading across the continental united states.',
    'the convoy of survivors pushed northward through the devastated countryside hoping to reach the rumored safe zone beyond the mountains. fuel was running low and the moaning of the horde echoed from the treeline on both sides of the crumbling highway.'
  ],
  nightmare: [
    'the evacuation order came too late for most of the population. by the time the emergency broadcast system activated the streets were already flooded with the shambling remains of what had once been friends and neighbors. the military established a perimeter around the city center but it crumbled within hours as wave after wave of reanimated corpses pushed through the barricades. those who survived the initial outbreak found themselves trapped in a nightmarish landscape where every shadow could hide a lurking threat and every sound could signal the approach of the insatiable horde.',
    'doctor chen stared at the microscope in disbelief as the dead tissue sample began regenerating before her eyes. the pathogen was unlike anything modern science had ever encountered. it rewrote cellular dna at a fundamental level transforming necrotic flesh into something that defied every known law of biology. she reached for the emergency phone to contact the centers for disease control but the line was already dead. through the reinforced laboratory window she could see the parking lot below where her colleagues were being overwhelmed by a growing mass of infected personnel. the containment had failed and she was running out of time to synthesize a countermeasure.',
    'the last broadcast from the international space station painted a grim picture of the world below. from orbit the astronauts could see entire cities going dark one by one as the power grid collapsed under the weight of the catastrophe. massive fires burned unchecked across three continents while the highways leading out of major metropolitan areas were clogged with abandoned vehicles stretching for hundreds of miles. the crew had enough supplies for approximately six months but with mission control silent and no prospect of a resupply mission they faced an impossible decision about whether to attempt reentry into a world that might no longer have any safe landing zones remaining.'
  ]
};

const DIFF_CONFIG = {
  easy:      { speedMult: 0.6,  spawnMult: 1.4,  zombieCountMult: 0.7,  rageMult: 1.25, label: 'EASY',      color: '#44ff44' },
  normal:    { speedMult: 1.0,  spawnMult: 1.0,  zombieCountMult: 1.0,  rageMult: 1.5,  label: 'NORMAL',    color: '#ffffff' },
  hard:      { speedMult: 1.3,  spawnMult: 0.7,  zombieCountMult: 1.3,  rageMult: 1.75, label: 'HARD',      color: '#ffaa00' },
  extreme:   { speedMult: 1.7,  spawnMult: 0.45, zombieCountMult: 1.7,  rageMult: 2.0,  label: 'EXTREME',   color: '#ff4444' },
  nightmare: { speedMult: 2.2,  spawnMult: 0.3,  zombieCountMult: 2.2,  rageMult: 2.0,  label: 'NIGHTMARE', color: '#cc00ff' }
};
const DIFF_ORDER = ['easy', 'normal', 'hard', 'extreme', 'nightmare'];
const LIVES_OPTIONS = [2, 3, 5, 0]; // 0 = unlimited
const LIVES_LABELS = ['2', '3', '5', 'UNLIMITED'];

// --- Audio Engine ---
class AudioEngine {
  constructor() { this.ctx = null; this.muted = false; this.initialized = false; }
  init() {
    if (this.initialized) return;
    try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.initialized = true; } catch(e) {}
  }
  playNote(freq, duration, type, volume) {
    if (!this.ctx || this.muted) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type || 'square'; osc.frequency.value = freq;
    gain.gain.setValueAtTime(volume || 0.1, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
    osc.connect(gain); gain.connect(this.ctx.destination);
    osc.start(); osc.stop(this.ctx.currentTime + duration);
  }
  playNoise(duration, volume) {
    if (!this.ctx || this.muted) return;
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.max(0, 1 - i / bufferSize);
    const source = this.ctx.createBufferSource(); source.buffer = buffer;
    const gain = this.ctx.createGain(); gain.gain.value = volume || 0.15;
    source.connect(gain); gain.connect(this.ctx.destination); source.start();
  }
  gunshot() { this.playNoise(0.08, 0.2); this.playNote(150, 0.05, 'sawtooth', 0.15); }
  keystroke() { this.playNote(800 + Math.random() * 400, 0.04, 'square', 0.03); }
  zombieDeath() { this.playNoise(0.2, 0.15); this.playNote(200, 0.15, 'sawtooth', 0.08); this.playNote(100, 0.3, 'sawtooth', 0.06); }
  zombieHit() { this.playNoise(0.05, 0.1); this.playNote(300, 0.05, 'square', 0.05); }
  playerHit() { this.playNote(100, 0.3, 'sawtooth', 0.15); this.playNote(80, 0.4, 'square', 0.1); }
  waveComplete() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.playNote(f, 0.2, 'square', 0.08), i * 100)); }
  gameOver() { [400, 350, 300, 200].forEach((f, i) => setTimeout(() => this.playNote(f, 0.4, 'sawtooth', 0.1), i * 200)); }
  menuSelect() { this.playNote(600, 0.08, 'square', 0.05); setTimeout(() => this.playNote(900, 0.08, 'square', 0.05), 50); }
  comboSound(c) { this.playNote(400 + Math.min(c, 10) * 80, 0.1, 'triangle', 0.06); }
  bossAppear() { this.playNoise(0.5, 0.25); [100, 80, 60, 50].forEach((f, i) => setTimeout(() => this.playNote(f, 0.5, 'sawtooth', 0.15), i * 150)); }
  bossDeath() { this.playNoise(0.6, 0.3); [200, 300, 400, 500, 600, 800, 1000].forEach((f, i) => setTimeout(() => { this.playNote(f, 0.3, 'square', 0.1); this.playNoise(0.1, 0.1); }, i * 80)); }
  minibossHit() { this.playNoise(0.08, 0.15); this.playNote(200, 0.08, 'sawtooth', 0.1); }
  heartGain() { this.playNote(523, 0.1, 'triangle', 0.08); setTimeout(() => this.playNote(784, 0.15, 'triangle', 0.08), 100); setTimeout(() => this.playNote(1047, 0.2, 'triangle', 0.1), 200); }
}

// --- Particle ---
class Particle {
  constructor(x, y, vx, vy, color, life, size) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.color = color; this.life = life; this.maxLife = life; this.size = size || 3;
  }
  update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.vy += 200 * dt; this.life -= dt; }
  draw(ctx) {
    const a = Math.max(0, this.life / this.maxLife);
    ctx.globalAlpha = a; ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.size * a, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// --- Floating Text (for WPM popups) ---
class FloatingText {
  constructor(x, y, text, color) {
    this.x = x; this.y = y; this.text = text; this.color = color;
    this.life = 1.5; this.maxLife = 1.5;
  }
  update(dt) { this.y -= 30 * dt; this.life -= dt; return this.life > 0; }
  draw(ctx) {
    const a = Math.max(0, this.life / this.maxLife);
    ctx.globalAlpha = a;
    ctx.font = 'bold 14px monospace';
    ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
    const tw = ctx.measureText(this.text).width;
    ctx.strokeText(this.text, this.x - tw / 2, this.y);
    ctx.fillStyle = this.color;
    ctx.fillText(this.text, this.x - tw / 2, this.y);
    ctx.globalAlpha = 1;
  }
}

// --- Zombie Class ---
class Zombie {
  constructor(word, x, y, speed, type, rageEnabled, rageMult) {
    this.word = word.toUpperCase();
    this.x = x; this.y = y;
    this.baseSpeed = speed;
    this.speed = speed;
    this.typed = 0;
    this.alive = true;
    this.health = 1.0;
    this.type = type || 'normal';
    this.targetX = PLAYER_X + (Math.random() - 0.5) * 100;
    this.targetY = PLAYER_Y;
    this.wobble = Math.random() * Math.PI * 2;
    this.wobbleSpeed = 1 + Math.random() * 2;
    this.flashTimer = 0;
    this.deathTimer = 0;
    this.dying = false;
    this.pulseTimer = 0;
    this.damageAmount = 1;
    this.rageEnabled = rageEnabled || false;
    this.rageMult = rageMult || 1.5;

    // WPM tracking
    this.typingStartTime = 0; // set when first letter typed
    this.typingErrors = 0;

    if (this.type === 'normal') {
      this.radius = 25 + Math.random() * 8;
    } else if (this.type === 'miniboss') {
      this.radius = 38 + Math.random() * 5;
      this.damageAmount = 2;
    } else if (this.type === 'boss') {
      this.radius = 60;
      this.damageAmount = 3;
      this.wobbleSpeed = 0.5;
    }
  }

  update(dt) {
    if (this.dying) {
      this.deathTimer += dt;
      return this.deathTimer < (this.type === 'boss' ? 1.0 : (this.type === 'miniboss' ? 0.5 : 0.3));
    }

    this.wobble += this.wobbleSpeed * dt;
    this.pulseTimer += dt;

    // Rage mode: speed increases as health drops
    if (this.rageEnabled && this.typed > 0) {
      const healthPct = this.health;
      // Lerp from 1.0 at full health to rageMult at 0 health
      this.speed = this.baseSpeed * (1 + (this.rageMult - 1) * (1 - healthPct));
    }

    const dx = this.targetX - this.x;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 1) {
      this.x += (dx / dist) * this.speed * dt + Math.sin(this.wobble) * 0.5;
      this.y += (dy / dist) * this.speed * dt;
    }
    if (this.flashTimer > 0) this.flashTimer -= dt;
    this.health = 1 - (this.typed / this.word.length);
    return true;
  }

  reachedPlayer() { return this.y >= GROUND_Y - 10 && !this.dying; }

  // Calculate typing speed for this zombie
  getWPM() {
    if (!this.typingStartTime || this.typed < 2) return 0;
    const elapsed = (performance.now() - this.typingStartTime) / 1000; // seconds
    if (elapsed < 0.1) return 0;
    const words = this.word.length / 5; // standard: 5 chars = 1 word
    return Math.round(words / (elapsed / 60));
  }

  draw(ctx) {
    const deathDur = this.type === 'boss' ? 1.0 : (this.type === 'miniboss' ? 0.5 : 0.3);
    if (this.dying) {
      const t = this.deathTimer / deathDur;
      ctx.globalAlpha = 1 - t;
      if (this.type === 'boss') {
        ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 4 * (1 - t);
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 + t * 4), 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = '#ff4400';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 - t * 0.5), 0, Math.PI * 2); ctx.fill();
      } else {
        ctx.fillStyle = this.type === 'miniboss' ? '#aa00ff' : '#ff6600';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 + t * 2), 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      return;
    }

    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(this.x, this.y + this.radius + 5, this.radius * 0.8, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    if (this.type === 'boss') this._drawBoss(ctx);
    else if (this.type === 'miniboss') this._drawMiniboss(ctx);
    else this._drawNormal(ctx);

    this._drawWord(ctx);
  }

  // Determine if word should be below the zombie (not enough space above)
  _wordBelow() {
    if (this.type === 'boss') {
      // Boss text box is tall â€” show below if near top
      return this.y < 200;
    }
    // For normal/miniboss: need ~55px above zombie center
    return this.y - this.radius - 55 < 5;
  }

  _drawNormal(ctx) {
    ctx.shadowBlur = 15;
    ctx.shadowColor = this.flashTimer > 0 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.4)';
    ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : (this.health < 0.4 ? '#8b0000' : '#cc3333');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = this.health < 0.4 ? '#660000' : '#aa2222';
    ctx.beginPath(); ctx.arc(this.x + 3, this.y + 5, this.radius * 0.6, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ffff00';
    ctx.beginPath(); ctx.arc(this.x - 8, this.y - 5, 5, 0, Math.PI * 2); ctx.arc(this.x + 8, this.y - 5, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(this.x - 7, this.y - 5, 2, 0, Math.PI * 2); ctx.arc(this.x + 9, this.y - 5, 2, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(this.x, this.y + 8, 8, 0.1 * Math.PI, 0.9 * Math.PI); ctx.stroke();
    this._drawHealthBar(ctx, 60);
  }

  _drawMiniboss(ctx) {
    const pulse = Math.sin(this.pulseTimer * 3) * 0.08;
    ctx.shadowBlur = 25;
    ctx.shadowColor = this.flashTimer > 0 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(160, 0, 255, 0.6)';
    ctx.fillStyle = '#6600aa';
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 + this.pulseTimer * 0.5;
      const spikeLen = this.radius * (0.5 + pulse);
      const sx = this.x + Math.cos(angle) * this.radius;
      const sy = this.y + Math.sin(angle) * this.radius;
      const tx = this.x + Math.cos(angle) * (this.radius + spikeLen);
      const ty = this.y + Math.sin(angle) * (this.radius + spikeLen);
      const px = -Math.sin(angle) * 8; const py = Math.cos(angle) * 8;
      ctx.beginPath(); ctx.moveTo(sx - px, sy - py); ctx.lineTo(tx, ty); ctx.lineTo(sx + px, sy + py); ctx.closePath(); ctx.fill();
    }
    ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : (this.health < 0.4 ? '#440066' : '#7722bb');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 + pulse), 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = this.health < 0.4 ? '#330044' : '#5500aa';
    ctx.beginPath(); ctx.arc(this.x + 4, this.y + 6, this.radius * 0.55, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ff0000';
    ctx.beginPath(); ctx.arc(this.x - 12, this.y - 6, 6, 0, Math.PI * 2); ctx.arc(this.x + 12, this.y - 6, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff4444';
    ctx.beginPath(); ctx.arc(this.x, this.y - 14, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(this.x - 11, this.y - 6, 2.5, 0, Math.PI * 2); ctx.arc(this.x + 13, this.y - 6, 2.5, 0, Math.PI * 2); ctx.arc(this.x + 1, this.y - 14, 2, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    ctx.beginPath();
    const mY = this.y + 10;
    ctx.moveTo(this.x - 15, mY);
    for (let i = 0; i < 6; i++) ctx.lineTo(this.x - 15 + i * 6, mY + (i % 2 ? -5 : 5));
    ctx.stroke();
    ctx.font = 'bold 10px monospace'; ctx.fillStyle = '#cc66ff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    const label = 'MINI-BOSS'; const lw = ctx.measureText(label).width;
    ctx.strokeText(label, this.x - lw / 2, this.y + this.radius + 18);
    ctx.fillText(label, this.x - lw / 2, this.y + this.radius + 18);
    this._drawHealthBar(ctx, 80);
  }

  _drawBoss(ctx) {
    const pulse = Math.sin(this.pulseTimer * 2) * 0.05;
    const r = this.radius * (1 + pulse);
    ctx.strokeStyle = `rgba(255, 50, 0, ${0.2 + Math.sin(this.pulseTimer * 4) * 0.1})`; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(this.x, this.y, r + 20 + Math.sin(this.pulseTimer * 3) * 5, 0, Math.PI * 2); ctx.stroke();
    ctx.strokeStyle = `rgba(255, 100, 0, ${0.15 + Math.sin(this.pulseTimer * 3) * 0.1})`;
    ctx.beginPath(); ctx.arc(this.x, this.y, r + 35 + Math.sin(this.pulseTimer * 2) * 8, 0, Math.PI * 2); ctx.stroke();
    ctx.shadowBlur = 40;
    ctx.shadowColor = this.flashTimer > 0 ? 'rgba(255, 255, 0, 1)' : 'rgba(255, 0, 0, 0.8)';
    ctx.fillStyle = '#442200';
    ctx.beginPath(); ctx.moveTo(this.x - 30, this.y - r * 0.6); ctx.lineTo(this.x - 55, this.y - r - 30); ctx.lineTo(this.x - 15, this.y - r * 0.3); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(this.x + 30, this.y - r * 0.6); ctx.lineTo(this.x + 55, this.y - r - 30); ctx.lineTo(this.x + 15, this.y - r * 0.3); ctx.closePath(); ctx.fill();
    ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : (this.health < 0.3 ? '#550000' : '#991111');
    ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = this.health < 0.3 ? '#330000' : '#661111'; ctx.lineWidth = 2;
    for (let i = 0; i < 5; i++) { const a = (i / 5) * Math.PI * 2 + 0.3; ctx.beginPath(); ctx.moveTo(this.x + Math.cos(a) * r * 0.3, this.y + Math.sin(a) * r * 0.3); ctx.lineTo(this.x + Math.cos(a) * r * 0.8, this.y + Math.sin(a) * r * 0.8); ctx.stroke(); }
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
    ctx.beginPath(); ctx.ellipse(this.x - 18, this.y - 10, 12, 8, -0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(this.x + 18, this.y - 10, 12, 8, 0.2, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.ellipse(this.x - 17, this.y - 10, 3, 7, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(this.x + 19, this.y - 10, 3, 7, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#330000'; ctx.beginPath(); ctx.ellipse(this.x, this.y + 18, 25, 12, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ccccaa';
    for (let i = 0; i < 7; i++) { ctx.fillRect(this.x - 21 + i * 7, this.y + 10, 5, 8); ctx.fillRect(this.x - 21 + i * 7, this.y + 22, 5, 7); }
    ctx.font = 'bold 14px monospace'; ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
    const label = 'BOSS'; const lw = ctx.measureText(label).width;
    ctx.strokeText(label, this.x - lw / 2, this.y + r + 22);
    ctx.fillText(label, this.x - lw / 2, this.y + r + 22);
    this._drawHealthBar(ctx, 140);
  }

  _drawHealthBar(ctx, barW) {
    const barH = this.type === 'boss' ? 10 : 6;
    const below = this._wordBelow();
    let barY;
    if (below) {
      barY = this.y + this.radius + (this.type === 'miniboss' ? 25 : 15);
    } else {
      barY = this.y - this.radius - (this.type === 'boss' ? 50 : 35);
    }
    const barX = this.x - barW / 2;
    ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barW, barH);
    let hpColor;
    if (this.type === 'boss') hpColor = this.health > 0.5 ? '#ff4444' : (this.health > 0.25 ? '#ff2200' : '#cc0000');
    else if (this.type === 'miniboss') hpColor = this.health > 0.5 ? '#aa44ff' : (this.health > 0.25 ? '#8800cc' : '#660099');
    else hpColor = this.health > 0.5 ? '#00ff00' : (this.health > 0.25 ? '#ffaa00' : '#ff4444');
    ctx.fillStyle = hpColor; ctx.fillRect(barX, barY, barW * this.health, barH);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barW, barH);
    if (this.type === 'boss') {
      ctx.font = 'bold 10px monospace'; ctx.fillStyle = '#fff';
      const pct = Math.ceil(this.health * 100) + '%';
      ctx.fillText(pct, this.x - ctx.measureText(pct).width / 2, barY - 3);
    }
  }

  _drawWord(ctx) {
    if (this.type === 'boss') { this._drawBossWord(ctx); return; }
    const below = this._wordBelow();
    const fontSize = this.type === 'miniboss' ? 18 : 22;
    ctx.font = `bold ${fontSize}px monospace`;

    let wordY;
    if (below) {
      const barOffset = this.type === 'miniboss' ? 25 : 15;
      wordY = this.y + this.radius + barOffset + 6 + fontSize + 4; // below health bar
    } else {
      const barY = this.y - this.radius - 35;
      wordY = barY - 8;
    }

    for (let i = 0; i < this.word.length; i++) {
      const ch = this.word[i];
      const totalWidth = ctx.measureText(this.word).width;
      const charX = this.x - totalWidth / 2 + ctx.measureText(this.word.substring(0, i)).width;
      ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.strokeText(ch, charX, wordY);
      if (i < this.typed) ctx.fillStyle = '#00ff41';
      else if (this.typed > 0 && i === this.typed) ctx.fillStyle = '#ffff00';
      else ctx.fillStyle = '#ffffff';
      ctx.fillText(ch, charX, wordY);
    }
  }

  _drawBossWord(ctx) {
    const maxLineW = 400;
    const fontSize = 16;
    ctx.font = `bold ${fontSize}px monospace`;
    const words = []; let current = '';
    for (let i = 0; i < this.word.length; i++) {
      current += this.word[i];
      if (this.word[i] === ' ' || i === this.word.length - 1) { words.push(current); current = ''; }
    }
    const lines = []; let line = '';
    for (const w of words) {
      const test = line + w;
      if (ctx.measureText(test).width > maxLineW && line.length > 0) { lines.push(line); line = w; }
      else line = test;
    }
    if (line) lines.push(line);

    const lineH = fontSize + 4;
    const boxH = lines.length * lineH + 16;
    const boxW = maxLineW + 30;
    const below = this._wordBelow();
    const boxX = this.x - boxW / 2;
    let boxY;
    if (below) {
      boxY = this.y + this.radius + 30;
    } else {
      boxY = this.y - this.radius - boxH - 55;
    }

    // Clamp box to canvas
    if (boxX < 5) { /* shift right */ }
    const clampedBoxX = Math.max(5, Math.min(CANVAS_W - boxW - 5, boxX));

    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(clampedBoxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2;
    ctx.strokeRect(clampedBoxX, boxY, boxW, boxH);

    let charIdx = 0;
    for (let li = 0; li < lines.length; li++) {
      const ly = boxY + 14 + li * lineH;
      let cx = clampedBoxX + 15;
      for (let ci = 0; ci < lines[li].length; ci++) {
        const ch = lines[li][ci];
        if (charIdx < this.typed) ctx.fillStyle = '#00ff41';
        else if (charIdx === this.typed) ctx.fillStyle = '#ffff00';
        else ctx.fillStyle = '#cccccc';
        ctx.fillText(ch, cx, ly);
        cx += ctx.measureText(ch).width;
        charIdx++;
      }
    }
  }
}

// --- Tracer ---
class Tracer {
  constructor(x1, y1, x2, y2) { this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; this.life = 0.15; }
  update(dt) { this.life -= dt; return this.life > 0; }
  draw(ctx) { const a = this.life / 0.15; ctx.strokeStyle = `rgba(0, 255, 65, ${a})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x1, this.y1); ctx.lineTo(this.x2, this.y2); ctx.stroke(); }
}

// --- Muzzle Flash ---
class MuzzleFlash {
  constructor(x, y) { this.x = x; this.y = y; this.life = 0.06; }
  update(dt) { this.life -= dt; return this.life > 0; }
  draw(ctx) {
    const a = this.life / 0.06; const s = 12 * a;
    ctx.fillStyle = `rgba(255, 255, 100, ${a * 0.8})`; ctx.beginPath(); ctx.arc(this.x, this.y - 15, s, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = `rgba(255, 200, 50, ${a * 0.5})`; ctx.beginPath(); ctx.arc(this.x, this.y - 15, s * 1.5, 0, Math.PI * 2); ctx.fill();
  }
}

// --- Main Game ---
class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.canvas.width = CANVAS_W; this.canvas.height = CANVAS_H;
    this.ctx = this.canvas.getContext('2d');
    this.container = document.getElementById('gameContainer');
    this.audio = new AudioEngine();
    this.state = 'menu';
    this.difficulty = 'normal';
    this.livesOptionIdx = 1; // index into LIVES_OPTIONS (default 3)
    this.rageMode = false;

    this.zombies = []; this.particles = []; this.tracers = []; this.flashes = [];
    this.floatingTexts = [];
    this.score = 0; this.wave = 0; this.lives = 3; this.maxLives = 3;
    this.combo = 0; this.maxCombo = 0;
    this.totalKills = 0; this.totalLettersTyped = 0; this.totalErrors = 0;
    this.currentInput = ''; this.targetZombie = null;
    this.waveTimer = 0; this.zombiesInWave = 0; this.zombiesSpawned = 0;
    this.spawnTimer = 0; this.waveComplete = false; this.waveAnnounceTimer = 0;
    this.isBossWave = false; this.bossSpawned = false;
    this.minibossSpawnedThisWave = false;
    this.screenShake = 0; this.screenShakeX = 0; this.screenShakeY = 0;

    // WPM tracking per wave
    this.waveWpmSamples = [];
    this.lastWaveAvgWpm = 0;
    this.lastWaveErrors = 0;

    // Retry state
    this.retryWave = 0;
    this.retryScore = 0;

    this.menuSelection = 0;
    this.menuItems = ['START GAME', 'HIGH SCORES', 'OPTIONS'];
    this.optionSelection = 0;
    this.gameOverSelection = 0; // 0 = retry, 1 = menu

    this.highScores = this.loadHighScores();
    this.stats = this.loadStats();
    this.lastTime = 0;

    this.setupInput();
    requestAnimationFrame((t) => this.loop(t));
  }

  // --- Storage ---
  loadHighScores() { try { return JSON.parse(localStorage.getItem('totd_highscores')) || []; } catch { return []; } }
  saveHighScores() { try { localStorage.setItem('totd_highscores', JSON.stringify(this.highScores.slice(0, 10))); } catch {} }
  loadStats() {
    try { return JSON.parse(localStorage.getItem('totd_stats')) || { totalKills: 0, totalGames: 0, bestWave: 0, bestCombo: 0 }; }
    catch { return { totalKills: 0, totalGames: 0, bestWave: 0, bestCombo: 0 }; }
  }
  saveStats() { try { localStorage.setItem('totd_stats', JSON.stringify(this.stats)); } catch {} }
  addHighScore(score, wave) {
    const entry = { score, wave, date: new Date().toLocaleDateString(), difficulty: this.difficulty };
    this.highScores.push(entry); this.highScores.sort((a, b) => b.score - a.score);
    this.highScores = this.highScores.slice(0, 10); this.saveHighScores();
    return this.highScores.indexOf(entry);
  }

  isUnlimitedLives() { return LIVES_OPTIONS[this.livesOptionIdx] === 0; }
  getStartLives() {
    if (this.isUnlimitedLives()) return 99;
    return LIVES_OPTIONS[this.livesOptionIdx];
  }

  // --- Input ---
  setupInput() {
    this.container.addEventListener('keydown', (e) => {
      if (['Space', 'Escape', 'ArrowUp', 'ArrowDown', 'Enter', 'Tab'].includes(e.code)) e.preventDefault();
      this.audio.init();
      switch (this.state) {
        case 'menu': this.handleMenuInput(e); break;
        case 'playing': this.handleGameInput(e); break;
        case 'paused': this.handlePauseInput(e); break;
        case 'gameover': this.handleGameOverInput(e); break;
        case 'highscores': this.handleHighScoreInput(e); break;
        case 'options': this.handleOptionsInput(e); break;
      }
    });
    this.container.focus();
  }

  handleMenuInput(e) {
    if (e.code === 'ArrowUp') { this.menuSelection = (this.menuSelection - 1 + this.menuItems.length) % this.menuItems.length; this.audio.keystroke(); }
    else if (e.code === 'ArrowDown') { this.menuSelection = (this.menuSelection + 1) % this.menuItems.length; this.audio.keystroke(); }
    else if (e.code === 'Enter' || e.code === 'Space') {
      this.audio.menuSelect();
      if (this.menuSelection === 0) this.startGame();
      else if (this.menuSelection === 1) this.state = 'highscores';
      else if (this.menuSelection === 2) this.state = 'options';
    }
  }

  handleGameInput(e) {
    if (e.code === 'Escape') { this.state = 'paused'; return; }
    if (e.code === 'Backspace') {
      e.preventDefault();
      if (this.currentInput.length > 0) {
        this.currentInput = this.currentInput.slice(0, -1);
        if (this.currentInput.length === 0) { if (this.targetZombie) this.targetZombie.typed = 0; this.targetZombie = null; }
        else if (this.targetZombie) this.targetZombie.typed = this.currentInput.length;
      }
      return;
    }

    let ch = null;
    if (e.code === 'Space') ch = ' ';
    else if (e.key.length === 1) { ch = e.key.toUpperCase(); if (!/[A-Z .,;:!?'\-]/.test(ch)) return; }
    else return;

    this.audio.keystroke();
    this.totalLettersTyped++;

    if (this.targetZombie && this.targetZombie.alive) {
      const nextChar = this.targetZombie.word[this.currentInput.length];
      if (ch === nextChar) {
        this.currentInput += ch;
        this.targetZombie.typed = this.currentInput.length;
        this.targetZombie.flashTimer = 0.08;

        // Start WPM timer on first letter
        if (this.targetZombie.typed === 1) {
          this.targetZombie.typingStartTime = performance.now();
        }

        if (this.targetZombie.type === 'boss') this.audio.minibossHit();
        else this.audio.zombieHit();
        this.tracers.push(new Tracer(PLAYER_X, PLAYER_Y, this.targetZombie.x, this.targetZombie.y));
        this.flashes.push(new MuzzleFlash(PLAYER_X, PLAYER_Y));
        this.audio.gunshot();
        const pc = this.targetZombie.type === 'miniboss' ? '#aa44ff' : (this.targetZombie.type === 'boss' ? '#ff2200' : '#ff6644');
        for (let i = 0; i < 3; i++) this.particles.push(new Particle(this.targetZombie.x, this.targetZombie.y, (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, pc, 0.3 + Math.random() * 0.3, 3));

        if (this.currentInput.length === this.targetZombie.word.length) {
          this.killZombie(this.targetZombie);
          this.currentInput = ''; this.targetZombie = null;
        }
      } else {
        this.totalErrors++;
        if (this.targetZombie) this.targetZombie.typingErrors++;
        this.combo = 0;
        this.screenShake = 0.1;
      }
    } else {
      if (ch !== ' ') {
        const match = this.zombies.find(z => z.alive && !z.dying && z.word[0] === ch && z !== this.targetZombie);
        if (match) {
          this.targetZombie = match;
          this.currentInput = ch;
          match.typed = 1;
          match.typingStartTime = performance.now();
          match.flashTimer = 0.08;
          this.audio.zombieHit();
          this.tracers.push(new Tracer(PLAYER_X, PLAYER_Y, match.x, match.y));
          this.flashes.push(new MuzzleFlash(PLAYER_X, PLAYER_Y));
          this.audio.gunshot();
          for (let i = 0; i < 3; i++) this.particles.push(new Particle(match.x, match.y, (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, '#ff6644', 0.3, 3));
          if (match.word.length === 1) { this.killZombie(match); this.currentInput = ''; this.targetZombie = null; }
        } else { this.totalErrors++; this.combo = 0; }
      }
    }
  }

  handlePauseInput(e) { if (e.code === 'Escape' || e.code === 'Space') this.state = 'playing'; }

  handleGameOverInput(e) {
    if (e.code === 'ArrowUp' || e.code === 'ArrowDown') {
      this.gameOverSelection = this.gameOverSelection === 0 ? 1 : 0;
      this.audio.keystroke();
    } else if (e.code === 'Space' || e.code === 'Enter') {
      this.audio.menuSelect();
      if (this.gameOverSelection === 0) {
        this.retryCurrentWave();
      } else {
        this.state = 'menu';
      }
    } else if (e.code === 'KeyR') {
      this.audio.menuSelect();
      this.retryCurrentWave();
    }
  }

  handleHighScoreInput(e) { if (e.code === 'Escape' || e.code === 'Space' || e.code === 'Enter') this.state = 'menu'; }

  handleOptionsInput(e) {
    const maxOpt = 3; // 0=difficulty, 1=lives, 2=rage, 3=sound
    if (e.code === 'Escape') { this.state = 'menu'; return; }
    if (e.code === 'ArrowUp') { this.optionSelection = Math.max(0, this.optionSelection - 1); this.audio.keystroke(); }
    else if (e.code === 'ArrowDown') { this.optionSelection = Math.min(maxOpt, this.optionSelection + 1); this.audio.keystroke(); }
    else if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'Enter' || e.code === 'Space') {
      this.audio.menuSelect();
      const dir = e.code === 'ArrowLeft' ? -1 : 1;
      if (this.optionSelection === 0) {
        const idx = DIFF_ORDER.indexOf(this.difficulty);
        this.difficulty = DIFF_ORDER[(idx + dir + DIFF_ORDER.length) % DIFF_ORDER.length];
      } else if (this.optionSelection === 1) {
        this.livesOptionIdx = (this.livesOptionIdx + dir + LIVES_OPTIONS.length) % LIVES_OPTIONS.length;
      } else if (this.optionSelection === 2) {
        this.rageMode = !this.rageMode;
      } else if (this.optionSelection === 3) {
        this.audio.muted = !this.audio.muted;
      }
    }
  }

  // --- Game Logic ---
  startGame() {
    this.state = 'playing';
    this.score = 0; this.wave = 0;
    this.maxLives = this.getStartLives();
    this.lives = this.maxLives;
    this.combo = 0; this.maxCombo = 0;
    this.totalKills = 0; this.totalLettersTyped = 0; this.totalErrors = 0;
    this.currentInput = ''; this.targetZombie = null;
    this.zombies = []; this.particles = []; this.tracers = []; this.flashes = [];
    this.floatingTexts = [];
    this.waveWpmSamples = []; this.lastWaveAvgWpm = 0; this.lastWaveErrors = 0;
    this.waveComplete = true; this.waveTimer = 1.5;
    this.isBossWave = false; this.bossSpawned = false;
    this.minibossSpawnedThisWave = false;
    this.screenShake = 0;
    this.retryWave = 0; this.retryScore = 0;
  }

  retryCurrentWave() {
    this.state = 'playing';
    this.score = this.retryScore;
    this.lives = this.maxLives;
    this.combo = 0;
    this.currentInput = ''; this.targetZombie = null;
    this.zombies = []; this.particles = []; this.tracers = []; this.flashes = [];
    this.floatingTexts = [];
    this.waveWpmSamples = [];
    this.wave = this.retryWave - 1; // will be incremented by startWave
    this.waveComplete = true; this.waveTimer = 1.0;
    this.isBossWave = false; this.bossSpawned = false;
    this.minibossSpawnedThisWave = false;
    this.screenShake = 0;
  }

  startWave() {
    this.wave++;
    // Save retry checkpoint
    this.retryWave = this.wave;
    this.retryScore = this.score;

    this.waveComplete = false;
    this.isBossWave = (this.wave % 3 === 0);
    this.bossSpawned = false;
    this.minibossSpawnedThisWave = false;

    // Reset wave WPM tracking
    this.waveWpmSamples = [];

    const cfg = DIFF_CONFIG[this.difficulty];
    if (this.isBossWave) {
      const escorts = Math.floor(this.wave * 0.5 * cfg.zombieCountMult);
      this.zombiesInWave = 1 + escorts;
      this.waveAnnounceTimer = 3.0;
    } else {
      this.zombiesInWave = Math.floor((3 + this.wave * 2) * cfg.zombieCountMult);
      this.waveAnnounceTimer = 2.0;
    }
    this.zombiesSpawned = 0; this.spawnTimer = 0;
    this.audio.waveComplete();
  }

  getDiffConfig() { return DIFF_CONFIG[this.difficulty]; }

  getWordForWave() {
    let pool;
    if (this.difficulty === 'nightmare') {
      if (this.wave <= 1) pool = WORDS.medium;
      else if (this.wave <= 3) pool = Math.random() < 0.3 ? WORDS.medium : WORDS.hard;
      else if (this.wave <= 6) pool = Math.random() < 0.2 ? WORDS.hard : WORDS.extreme;
      else pool = Math.random() < 0.3 ? WORDS.extreme : WORDS.nightmare;
    } else if (this.difficulty === 'extreme') {
      if (this.wave <= 1) pool = WORDS.easy;
      else if (this.wave <= 3) pool = Math.random() < 0.4 ? WORDS.medium : WORDS.hard;
      else if (this.wave <= 6) pool = Math.random() < 0.3 ? WORDS.hard : WORDS.extreme;
      else pool = Math.random() < 0.4 ? WORDS.extreme : WORDS.hard;
    } else if (this.difficulty === 'hard') {
      if (this.wave <= 2) pool = Math.random() < 0.5 ? WORDS.easy : WORDS.medium;
      else if (this.wave <= 5) pool = Math.random() < 0.3 ? WORDS.medium : WORDS.hard;
      else pool = Math.random() < 0.2 ? WORDS.medium : WORDS.hard;
    } else if (this.difficulty === 'normal') {
      if (this.wave <= 2) pool = WORDS.easy;
      else if (this.wave <= 5) pool = Math.random() < 0.6 ? WORDS.easy : WORDS.medium;
      else if (this.wave <= 8) pool = Math.random() < 0.3 ? WORDS.easy : (Math.random() < 0.6 ? WORDS.medium : WORDS.hard);
      else pool = Math.random() < 0.1 ? WORDS.easy : (Math.random() < 0.5 ? WORDS.medium : WORDS.hard);
    } else {
      if (this.wave <= 3) pool = WORDS.easy;
      else if (this.wave <= 6) pool = Math.random() < 0.7 ? WORDS.easy : WORDS.medium;
      else pool = Math.random() < 0.4 ? WORDS.easy : WORDS.medium;
    }

    const activeWords = new Set(this.zombies.filter(z => z.alive).map(z => z.word));
    let word, attempts = 0;
    do { word = pool[Math.floor(Math.random() * pool.length)].toUpperCase(); attempts++; } while (activeWords.has(word) && attempts < 30);
    const activeFirst = new Set(this.zombies.filter(z => z.alive && z.typed === 0 && z.type === 'normal').map(z => z.word[0]));
    if (activeFirst.has(word[0])) { let r = 0; while (activeFirst.has(word[0]) && r < 20) { word = pool[Math.floor(Math.random() * pool.length)].toUpperCase(); r++; } }
    return word;
  }

  getBossText() {
    const pool = BOSS_TEXT[this.difficulty] || BOSS_TEXT.normal;
    return pool[Math.floor(Math.random() * pool.length)].toUpperCase();
  }

  getMinibossWord() {
    return WORDS.miniboss[Math.floor(Math.random() * WORDS.miniboss.length)].toUpperCase();
  }

  shouldSpawnMiniboss() {
    if (this.isBossWave || this.minibossSpawnedThisWave) return false;
    const active = this.zombies.filter(z => z.type === 'miniboss' && z.alive).length;
    if (active > 0) return false;
    // Spawn miniboss roughly 1/3 through each wave
    const progress = this.zombiesSpawned / this.zombiesInWave;
    return progress > 0.25 && progress < 0.4;
  }

  _makeZombie(word, x, y, speed, type) {
    const cfg = this.getDiffConfig();
    return new Zombie(word, x, y, speed, type, this.rageMode, cfg.rageMult);
  }

  spawnZombie() {
    const cfg = this.getDiffConfig();
    if (this.isBossWave && !this.bossSpawned) { this.spawnBoss(); this.bossSpawned = true; this.zombiesSpawned++; return; }
    if (this.shouldSpawnMiniboss()) { this.spawnMiniboss(); this.minibossSpawnedThisWave = true; this.zombiesSpawned++; return; }
    const word = this.getWordForWave();
    const pos = this._randomSpawnPos();
    const speed = (20 + this.wave * 3 + Math.random() * 15) * cfg.speedMult;
    this.zombies.push(this._makeZombie(word, pos.x, pos.y, speed, 'normal'));
    this.zombiesSpawned++;
  }

  spawnBoss() {
    const text = this.getBossText();
    const x = CANVAS_W / 2 + (Math.random() - 0.5) * 200;
    const cfg = this.getDiffConfig();
    const speed = (8 + this.wave * 1.5) * cfg.speedMult * 0.5;
    this.zombies.push(this._makeZombie(text, x, -60, speed, 'boss'));
    this.audio.bossAppear(); this.screenShake = 0.4;
  }

  spawnMiniboss() {
    const word = this.getMinibossWord();
    const pos = this._randomSpawnPos();
    const cfg = this.getDiffConfig();
    const speed = (15 + this.wave * 2) * cfg.speedMult * 0.7;
    this.zombies.push(this._makeZombie(word, pos.x, pos.y, speed, 'miniboss'));
  }

  _randomSpawnPos() {
    const s = Math.random();
    if (s < 0.6) return { x: 60 + Math.random() * (CANVAS_W - 120), y: -30 };
    if (s < 0.8) return { x: -30, y: 50 + Math.random() * 200 };
    return { x: CANVAS_W + 30, y: 50 + Math.random() * 200 };
  }

  killZombie(zombie) {
    zombie.dying = true; zombie.deathTimer = 0;
    this.combo++;
    if (this.combo > this.maxCombo) this.maxCombo = this.combo;
    this.totalKills++;

    // WPM tracking
    const wpm = zombie.getWPM();
    if (wpm > 0) {
      this.waveWpmSamples.push({ wpm, errors: zombie.typingErrors, chars: zombie.word.length });
      // Floating WPM text
      const wpmColor = wpm >= 100 ? '#ffaa00' : (wpm >= 60 ? '#00ff41' : '#aaaaaa');
      const errText = zombie.typingErrors > 0 ? ` (${zombie.typingErrors} err)` : '';
      this.floatingTexts.push(new FloatingText(zombie.x, zombie.y - zombie.radius - 20, `${wpm} WPM${errText}`, wpmColor));
    }

    let basePoints = zombie.word.length * 100;
    if (zombie.type === 'miniboss') basePoints *= 3;
    if (zombie.type === 'boss') basePoints *= 5;
    const comboMult = Math.min(1 + (this.combo - 1) * 0.25, 5);
    this.score += Math.floor(basePoints * comboMult);

    this.screenShake = zombie.type === 'boss' ? 0.6 : (zombie.type === 'miniboss' ? 0.3 : 0.15);

    const count = zombie.type === 'boss' ? 40 : (zombie.type === 'miniboss' ? 25 : 15);
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const spd = 50 + Math.random() * (zombie.type === 'boss' ? 400 : 200);
      const colors = zombie.type === 'boss' ? ['#ff4444', '#ff8844', '#ffaa00', '#ff0000']
        : (zombie.type === 'miniboss' ? ['#aa44ff', '#cc66ff', '#8800cc', '#ff44ff'] : ['#ff4444', '#ff8844']);
      this.particles.push(new Particle(zombie.x, zombie.y, Math.cos(angle) * spd, Math.sin(angle) * spd,
        colors[Math.floor(Math.random() * colors.length)], 0.5 + Math.random() * (zombie.type === 'boss' ? 1.0 : 0.5),
        2 + Math.random() * (zombie.type === 'boss' ? 8 : 4)));
    }

    // Boss kill: refill hearts + add 1 max heart
    if (zombie.type === 'boss' && !this.isUnlimitedLives()) {
      this.maxLives++;
      this.lives = this.maxLives;
      this.audio.heartGain();
      this.floatingTexts.push(new FloatingText(PLAYER_X, PLAYER_Y - 40, '+1 MAX HEART!', '#ff4444'));
    }

    if (zombie.type === 'boss') this.audio.bossDeath();
    else this.audio.zombieDeath();
    this.audio.comboSound(this.combo);
  }

  damagePlayer(amount) {
    if (this.isUnlimitedLives()) {
      // Still show feedback but don't reduce lives
      this.combo = 0; this.screenShake = 0.3; this.audio.playerHit();
      for (let i = 0; i < 20; i++) this.particles.push(new Particle(PLAYER_X + (Math.random() - 0.5) * 100, PLAYER_Y, (Math.random() - 0.5) * 200, -Math.random() * 200, '#ff0000', 0.5 + Math.random() * 0.3, 4));
      return;
    }
    this.lives -= (amount || 1);
    this.combo = 0; this.screenShake = 0.3; this.audio.playerHit();
    for (let i = 0; i < 20; i++) this.particles.push(new Particle(PLAYER_X + (Math.random() - 0.5) * 100, PLAYER_Y, (Math.random() - 0.5) * 200, -Math.random() * 200, '#ff0000', 0.5 + Math.random() * 0.3, 4));
    if (this.lives <= 0) { this.lives = 0; this.endGame(); }
  }

  endGame() {
    this.state = 'gameover';
    this.gameOverSelection = 0;
    this.audio.gameOver();

    // Compute wave avg WPM
    if (this.waveWpmSamples.length > 0) {
      this.lastWaveAvgWpm = Math.round(this.waveWpmSamples.reduce((s, w) => s + w.wpm, 0) / this.waveWpmSamples.length);
      this.lastWaveErrors = this.waveWpmSamples.reduce((s, w) => s + w.errors, 0);
    }

    this.stats.totalKills += this.totalKills;
    this.stats.totalGames++;
    if (this.wave > this.stats.bestWave) this.stats.bestWave = this.wave;
    if (this.maxCombo > this.stats.bestCombo) this.stats.bestCombo = this.maxCombo;
    this.saveStats();
    this.highScoreRank = this.addHighScore(this.score, this.wave);
  }

  getWaveAvgWpm() {
    if (this.waveWpmSamples.length === 0) return 0;
    return Math.round(this.waveWpmSamples.reduce((s, w) => s + w.wpm, 0) / this.waveWpmSamples.length);
  }

  // --- Update ---
  update(dt) {
    if (this.state !== 'playing') return;
    if (this.screenShake > 0) { this.screenShake -= dt; this.screenShakeX = (Math.random() - 0.5) * this.screenShake * 30; this.screenShakeY = (Math.random() - 0.5) * this.screenShake * 30; }
    else { this.screenShakeX = 0; this.screenShakeY = 0; }

    // Update floating texts
    for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
      if (!this.floatingTexts[i].update(dt)) this.floatingTexts.splice(i, 1);
    }

    if (this.waveComplete) { this.waveTimer -= dt; if (this.waveTimer <= 0) this.startWave(); return; }
    if (this.waveAnnounceTimer > 0) this.waveAnnounceTimer -= dt;

    if (this.zombiesSpawned < this.zombiesInWave) {
      this.spawnTimer -= dt;
      if (this.spawnTimer <= 0) {
        this.spawnZombie();
        const cfg = this.getDiffConfig();
        this.spawnTimer = Math.max(0.3, (2.5 - this.wave * 0.12)) * cfg.spawnMult;
      }
    }

    for (let i = this.zombies.length - 1; i >= 0; i--) {
      const z = this.zombies[i];
      if (!z.update(dt)) { if (z === this.targetZombie) { this.targetZombie = null; this.currentInput = ''; } this.zombies.splice(i, 1); continue; }
      if (z.reachedPlayer()) { if (z === this.targetZombie) { this.targetZombie = null; this.currentInput = ''; } z.alive = false; this.zombies.splice(i, 1); this.damagePlayer(z.damageAmount); }
    }

    if (this.zombiesSpawned >= this.zombiesInWave && this.zombies.filter(z => z.alive).length === 0) {
      this.waveComplete = true;
      this.waveTimer = this.isBossWave ? 3.5 : 2.5;
      this.score += this.wave * 200;
      if (this.isBossWave) this.score += this.wave * 500;

      // Store wave stats
      if (this.waveWpmSamples.length > 0) {
        this.lastWaveAvgWpm = this.getWaveAvgWpm();
        this.lastWaveErrors = this.waveWpmSamples.reduce((s, w) => s + w.errors, 0);
      }
    }

    for (let i = this.particles.length - 1; i >= 0; i--) { this.particles[i].update(dt); if (this.particles[i].life <= 0) this.particles.splice(i, 1); }
    for (let i = this.tracers.length - 1; i >= 0; i--) { if (!this.tracers[i].update(dt)) this.tracers.splice(i, 1); }
    for (let i = this.flashes.length - 1; i >= 0; i--) { if (!this.flashes[i].update(dt)) this.flashes.splice(i, 1); }
  }

  // --- Draw ---
  draw() {
    const ctx = this.ctx; ctx.save();
    if (this.state === 'playing' || this.state === 'gameover') ctx.translate(this.screenShakeX, this.screenShakeY);
    switch (this.state) {
      case 'menu': this.drawMenu(ctx); break;
      case 'playing': case 'paused': this.drawGameplay(ctx); if (this.state === 'paused') this.drawPause(ctx); break;
      case 'gameover': this.drawGameplay(ctx); this.drawGameOver(ctx); break;
      case 'highscores': this.drawHighScores(ctx); break;
      case 'options': this.drawOptions(ctx); break;
    }
    ctx.restore();
  }

  drawBackground(ctx) {
    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grad.addColorStop(0, '#0f0f1e'); grad.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    for (let i = 0; i < 50; i++) { ctx.beginPath(); ctx.arc((i * 137.5) % CANVAS_W, (i * 73.1) % (GROUND_Y - 50), ((i * 31.7) % 3) + 0.5, 0, Math.PI * 2); ctx.fill(); }
    ctx.fillStyle = '#16213e'; ctx.fillRect(0, GROUND_Y, CANVAS_W, CANVAS_H - GROUND_Y);
    ctx.strokeStyle = '#0f3460'; ctx.lineWidth = 1;
    for (let i = 0; i < CANVAS_W; i += 50) { ctx.beginPath(); ctx.moveTo(i, GROUND_Y); ctx.lineTo(i + 25, CANVAS_H); ctx.stroke(); }
    for (let y = GROUND_Y; y < CANVAS_H; y += 20) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_W, y); ctx.stroke(); }
  }

  drawPlayer(ctx) {
    ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(PLAYER_X - 20, PLAYER_Y); ctx.lineTo(PLAYER_X + 20, PLAYER_Y);
    ctx.moveTo(PLAYER_X, PLAYER_Y - 20); ctx.lineTo(PLAYER_X, PLAYER_Y + 20); ctx.stroke();
    ctx.fillStyle = '#00ff41'; ctx.beginPath(); ctx.arc(PLAYER_X, PLAYER_Y, 6, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(PLAYER_X, PLAYER_Y, 14, 0, Math.PI * 2); ctx.stroke();
  }

  drawHUD(ctx) {
    const cfg = DIFF_CONFIG[this.difficulty];
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(10, 10, 240, 85);
    ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 2; ctx.strokeRect(10, 10, 240, 85);
    ctx.font = 'bold 18px monospace'; ctx.fillStyle = '#00ff41';
    ctx.fillText(`SCORE: ${this.score.toLocaleString()}`, 22, 35);
    ctx.fillStyle = this.isBossWave ? '#ff4444' : '#00ff41';
    ctx.fillText(this.isBossWave ? `WAVE: ${this.wave} [BOSS]` : `WAVE: ${this.wave}`, 22, 58);

    if (this.combo > 1) { ctx.fillStyle = '#ffaa00'; ctx.font = 'bold 14px monospace'; ctx.fillText(`COMBO x${this.combo}`, 22, 75); }

    // WPM display
    const avgWpm = this.getWaveAvgWpm();
    if (avgWpm > 0) { ctx.font = '12px monospace'; ctx.fillStyle = '#88bbff'; ctx.fillText(`AVG: ${avgWpm} WPM`, 22, 90); }

    // Lives
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(CANVAS_W - 220, 10, 210, 50);
    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.strokeRect(CANVAS_W - 220, 10, 210, 50);
    ctx.font = 'bold 16px monospace'; ctx.fillStyle = '#ff4444';
    if (this.isUnlimitedLives()) {
      ctx.fillText('LIVES: UNLIMITED', CANVAS_W - 208, 36);
    } else {
      let hearts = '';
      const displayMax = Math.min(this.maxLives, 10);
      for (let i = 0; i < Math.min(this.lives, displayMax); i++) hearts += '\u2764 ';
      for (let i = Math.min(this.lives, displayMax); i < displayMax; i++) hearts += '\u2661 ';
      if (this.maxLives > 10) hearts += `+${this.maxLives - 10}`;
      ctx.fillText(`LIVES: ${hearts}`, CANVAS_W - 208, 36);
    }
    ctx.font = '12px monospace'; ctx.fillStyle = cfg.color;
    let label = cfg.label;
    if (this.rageMode) label += ' + RAGE';
    ctx.fillText(label, CANVAS_W - 208, 52);

    // Input box
    const inputW = this.targetZombie && this.targetZombie.type === 'boss' ? 450 : 320;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; ctx.fillRect(CANVAS_W / 2 - inputW / 2, CANVAS_H - 48, inputW, 40);
    let borderColor = '#335533';
    if (this.targetZombie) { borderColor = this.targetZombie.type === 'boss' ? '#ff4444' : (this.targetZombie.type === 'miniboss' ? '#aa44ff' : '#00ff41'); }
    ctx.strokeStyle = borderColor; ctx.lineWidth = 2; ctx.strokeRect(CANVAS_W / 2 - inputW / 2, CANVAS_H - 48, inputW, 40);
    ctx.font = 'bold 18px monospace'; ctx.fillStyle = '#00ff41';
    const displayText = this.currentInput || '';
    const cursor = (Date.now() % 1000 < 500) ? '_' : ' ';
    const maxD = Math.floor((inputW - 50) / 11);
    const shown = displayText.length > maxD ? '...' + displayText.slice(displayText.length - maxD + 3) : displayText;
    ctx.fillText(`> ${shown}${cursor}`, CANVAS_W / 2 - inputW / 2 + 10, CANVAS_H - 22);
  }

  drawGameplay(ctx) {
    this.drawBackground(ctx); this.drawPlayer(ctx);
    this.tracers.forEach(t => t.draw(ctx));
    this.flashes.forEach(f => f.draw(ctx));
    [...this.zombies].sort((a, b) => a.y - b.y).forEach(z => z.draw(ctx));
    this.particles.forEach(p => p.draw(ctx));
    this.floatingTexts.forEach(ft => ft.draw(ctx));

    if (this.targetZombie && this.targetZombie.alive && !this.targetZombie.dying) {
      const tz = this.targetZombie;
      ctx.strokeStyle = tz.type === 'boss' ? '#ff4444' : (tz.type === 'miniboss' ? '#aa44ff' : '#00ff41');
      ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
      ctx.beginPath(); ctx.arc(tz.x, tz.y, tz.radius + 10, 0, Math.PI * 2); ctx.stroke();
      ctx.setLineDash([]);
    }

    if (this.waveAnnounceTimer > 0) {
      const alpha = Math.min(1, this.waveAnnounceTimer / 0.5);
      ctx.globalAlpha = alpha;
      if (this.isBossWave) {
        ctx.font = 'bold 52px monospace'; ctx.fillStyle = '#ff0000'; ctx.strokeStyle = '#000'; ctx.lineWidth = 5;
        const t = `WAVE ${this.wave}`; let tw = ctx.measureText(t).width;
        ctx.strokeText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 60); ctx.fillText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 60);
        ctx.font = 'bold 36px monospace'; ctx.fillStyle = '#ff4444';
        const b = 'BOSS BATTLE'; tw = ctx.measureText(b).width;
        ctx.strokeText(b, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 15); ctx.fillText(b, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 15);
        ctx.font = '20px monospace'; ctx.fillStyle = '#ffaa00';
        const s = 'prepare yourself...'; ctx.fillText(s, CANVAS_W / 2 - ctx.measureText(s).width / 2, CANVAS_H / 2 + 20);
      } else {
        ctx.font = 'bold 48px monospace'; ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
        const t = `WAVE ${this.wave}`; const tw = ctx.measureText(t).width;
        ctx.strokeText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 50); ctx.fillText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 50);
        ctx.font = '24px monospace'; ctx.fillStyle = '#ffffff';
        const s = `${this.zombiesInWave} zombies incoming`; ctx.strokeText(s, CANVAS_W / 2 - ctx.measureText(s).width / 2, CANVAS_H / 2 - 10); ctx.fillText(s, CANVAS_W / 2 - ctx.measureText(s).width / 2, CANVAS_H / 2 - 10);
      }
      ctx.globalAlpha = 1;
    }

    if (this.waveComplete && this.wave > 0) {
      ctx.font = 'bold 32px monospace'; ctx.fillStyle = '#00ff41'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      const t = this.isBossWave ? 'BOSS DEFEATED!' : 'WAVE COMPLETE!'; let tw = ctx.measureText(t).width;
      ctx.strokeText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 30); ctx.fillText(t, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 30);
      ctx.font = '20px monospace'; ctx.fillStyle = '#ffaa00';
      const bonus = `Wave Bonus: +${this.wave * 200 + (this.isBossWave ? this.wave * 500 : 0)}`;
      ctx.strokeText(bonus, CANVAS_W / 2 - ctx.measureText(bonus).width / 2, CANVAS_H / 2 + 10); ctx.fillText(bonus, CANVAS_W / 2 - ctx.measureText(bonus).width / 2, CANVAS_H / 2 + 10);

      // Show wave WPM summary
      if (this.lastWaveAvgWpm > 0) {
        ctx.font = '16px monospace'; ctx.fillStyle = '#88bbff';
        const wpmText = `Wave Speed: ${this.lastWaveAvgWpm} WPM avg`;
        ctx.fillText(wpmText, CANVAS_W / 2 - ctx.measureText(wpmText).width / 2, CANVAS_H / 2 + 40);
      }
    }
    this.drawHUD(ctx);
  }

  drawMenu(ctx) {
    this.drawBackground(ctx);
    ctx.globalAlpha = 0.15;
    for (let i = 0; i < 8; i++) { ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc((i * 137) % CANVAS_W, 150 + (i * 89) % 300, 20 + (i % 3) * 5, 0, Math.PI * 2); ctx.fill(); }
    ctx.globalAlpha = 1;
    ctx.font = 'bold 56px monospace'; ctx.strokeStyle = '#000'; ctx.lineWidth = 6;
    const title = 'TYPE OF THE DEAD'; const titleW = ctx.measureText(title).width; const titleX = CANVAS_W / 2 - titleW / 2;
    ctx.strokeText(title, titleX, 130);
    const tg = ctx.createLinearGradient(titleX, 80, titleX, 140); tg.addColorStop(0, '#ff6666'); tg.addColorStop(1, '#cc0000');
    ctx.fillStyle = tg; ctx.fillText(title, titleX, 130);
    ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(255, 0, 0, 0.5)'; ctx.fillText(title, titleX, 130); ctx.shadowBlur = 0;
    ctx.font = 'italic 18px monospace'; ctx.fillStyle = '#00ff41';
    const sub = 'Survive the zombie apocalypse with your keyboard';
    ctx.fillText(sub, CANVAS_W / 2 - ctx.measureText(sub).width / 2, 170);

    this.menuItems.forEach((item, i) => {
      const y = 260 + i * 80; const sel = i === this.menuSelection;
      ctx.fillStyle = sel ? 'rgba(255, 68, 68, 0.3)' : 'rgba(255, 68, 68, 0.1)';
      ctx.fillRect(CANVAS_W / 2 - 160, y, 320, 60);
      ctx.strokeStyle = sel ? '#ff4444' : '#662222'; ctx.lineWidth = sel ? 3 : 1;
      ctx.strokeRect(CANVAS_W / 2 - 160, y, 320, 60);
      if (sel) { ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(255, 68, 68, 0.5)'; }
      ctx.font = 'bold 24px monospace'; ctx.fillStyle = sel ? '#ffffff' : '#888888';
      const iw = ctx.measureText(item).width; ctx.fillText(item, CANVAS_W / 2 - iw / 2, y + 38); ctx.shadowBlur = 0;
      if (sel) { ctx.fillStyle = '#ff4444'; ctx.fillText('>', CANVAS_W / 2 - iw / 2 - 30, y + 38); }
    });
    ctx.font = '14px monospace'; ctx.fillStyle = '#555';
    ctx.fillText('Arrow Keys to navigate | Enter to select', CANVAS_W / 2 - 180, CANVAS_H - 30);
  }

  drawPause(ctx) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.font = 'bold 48px monospace'; ctx.fillStyle = '#00ff41'; ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
    const t = 'PAUSED'; ctx.strokeText(t, CANVAS_W / 2 - ctx.measureText(t).width / 2, CANVAS_H / 2 - 20); ctx.fillText(t, CANVAS_W / 2 - ctx.measureText(t).width / 2, CANVAS_H / 2 - 20);
    ctx.font = '20px monospace'; ctx.fillStyle = '#aaa';
    const h = 'Press ESC or SPACE to resume'; ctx.fillText(h, CANVAS_W / 2 - ctx.measureText(h).width / 2, CANVAS_H / 2 + 30);
  }

  drawGameOver(ctx) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.font = 'bold 64px monospace'; ctx.fillStyle = '#ff0000'; ctx.strokeStyle = '#000'; ctx.lineWidth = 5;
    const title = 'GAME OVER'; const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 100); ctx.fillText(title, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 100);

    ctx.font = 'bold 22px monospace'; ctx.fillStyle = '#ffffff';
    const acc = this.totalLettersTyped > 0 ? Math.round((1 - this.totalErrors / this.totalLettersTyped) * 100) : 0;
    const lines = [
      `Final Score: ${this.score.toLocaleString()}`,
      `Wave Reached: ${this.wave}`,
      `Zombies Killed: ${this.totalKills}`,
      `Max Combo: ${this.maxCombo}x`,
      `Accuracy: ${acc}%`,
    ];
    if (this.lastWaveAvgWpm > 0) lines.push(`Avg Speed: ${this.lastWaveAvgWpm} WPM`);

    lines.forEach((line, i) => { const lw = ctx.measureText(line).width; ctx.fillText(line, CANVAS_W / 2 - lw / 2, CANVAS_H / 2 - 50 + i * 30); });

    const btnY = CANVAS_H / 2 + lines.length * 30 - 30;

    // Retry / Menu buttons
    const btns = [`RETRY WAVE ${this.retryWave}`, 'RETURN TO MENU'];
    btns.forEach((btn, i) => {
      const y = btnY + i * 50;
      const sel = i === this.gameOverSelection;
      ctx.fillStyle = sel ? 'rgba(0, 255, 65, 0.2)' : 'rgba(255, 255, 255, 0.05)';
      ctx.fillRect(CANVAS_W / 2 - 160, y, 320, 40);
      ctx.strokeStyle = sel ? '#00ff41' : '#444'; ctx.lineWidth = sel ? 2 : 1;
      ctx.strokeRect(CANVAS_W / 2 - 160, y, 320, 40);
      ctx.font = 'bold 18px monospace'; ctx.fillStyle = sel ? '#00ff41' : '#888';
      const bw = ctx.measureText(btn).width;
      ctx.fillText(btn, CANVAS_W / 2 - bw / 2, y + 26);
      if (sel) { ctx.fillText('>', CANVAS_W / 2 - bw / 2 - 25, y + 26); }
    });

    if (this.highScoreRank === 0) {
      ctx.font = 'bold 24px monospace'; ctx.fillStyle = '#ffaa00';
      const hs = 'NEW HIGH SCORE!'; ctx.fillText(hs, CANVAS_W / 2 - ctx.measureText(hs).width / 2, btnY + 120);
    } else if (this.highScoreRank !== -1 && this.highScoreRank < 10) {
      ctx.font = '18px monospace'; ctx.fillStyle = '#ffaa00';
      const hs = `Ranked #${this.highScoreRank + 1} on leaderboard!`;
      ctx.fillText(hs, CANVAS_W / 2 - ctx.measureText(hs).width / 2, btnY + 120);
    }

    ctx.font = '12px monospace'; ctx.fillStyle = '#555';
    ctx.fillText('Arrow Keys + Enter to select | R to retry', CANVAS_W / 2 - 170, CANVAS_H - 20);
  }

  drawHighScores(ctx) {
    this.drawBackground(ctx);
    ctx.font = 'bold 40px monospace'; ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
    const title = 'HIGH SCORES'; const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, 70); ctx.fillText(title, CANVAS_W / 2 - tw / 2, 70);
    if (this.highScores.length === 0) { ctx.font = '20px monospace'; ctx.fillStyle = '#666'; ctx.fillText('No scores yet. Go kill some zombies!', CANVAS_W / 2 - 210, CANVAS_H / 2); }
    else {
      ctx.font = 'bold 14px monospace'; ctx.fillStyle = '#00ff41';
      ctx.fillText('RANK  SCORE         WAVE  DIFFICULTY    DATE', 90, 120);
      ctx.font = '14px monospace';
      this.highScores.forEach((e, i) => {
        ctx.fillStyle = i === 0 ? '#ffaa00' : (i < 3 ? '#cccccc' : '#888888');
        ctx.fillText(`#${(i + 1).toString().padStart(2)}  ${e.score.toLocaleString().padStart(12)}   ${e.wave.toString().padStart(4)}  ${(e.difficulty || 'normal').padStart(12)}  ${e.date || ''}`, 90, 150 + i * 32);
      });
    }
    ctx.font = 'bold 18px monospace'; ctx.fillStyle = '#00ff41'; ctx.fillText('CAREER STATS', 90, CANVAS_H - 130);
    ctx.font = '14px monospace'; ctx.fillStyle = '#aaa';
    ctx.fillText(`Games: ${this.stats.totalGames}  |  Kills: ${this.stats.totalKills}  |  Best Wave: ${this.stats.bestWave}  |  Best Combo: ${this.stats.bestCombo}x`, 90, CANVAS_H - 100);
    ctx.font = '14px monospace'; ctx.fillStyle = '#555';
    ctx.fillText('Press ESC or SPACE to return', CANVAS_W / 2 - 130, CANVAS_H - 30);
  }

  drawOptions(ctx) {
    this.drawBackground(ctx);
    ctx.font = 'bold 40px monospace'; ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
    const title = 'OPTIONS'; const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, 80); ctx.fillText(title, CANVAS_W / 2 - tw / 2, 80);

    const cfg = DIFF_CONFIG[this.difficulty];
    const opts = [
      { label: 'Difficulty', value: cfg.label, hint: 'Left/Right to change', valueColor: cfg.color },
      { label: 'Lives', value: LIVES_LABELS[this.livesOptionIdx], hint: 'Left/Right to change', valueColor: this.isUnlimitedLives() ? '#ffaa00' : null },
      { label: 'Rage Mode', value: this.rageMode ? 'ON' : 'OFF', hint: 'Zombies speed up as you type', valueColor: this.rageMode ? '#ff4444' : null },
      { label: 'Sound', value: this.audio.muted ? 'OFF' : 'ON', hint: 'Enter to toggle', valueColor: null },
    ];

    opts.forEach((opt, i) => {
      const y = 150 + i * 75;
      const sel = i === this.optionSelection;
      ctx.fillStyle = sel ? 'rgba(0, 255, 65, 0.1)' : 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(CANVAS_W / 2 - 220, y - 15, 440, 55);
      ctx.strokeStyle = sel ? '#00ff41' : '#333'; ctx.lineWidth = sel ? 2 : 1;
      ctx.strokeRect(CANVAS_W / 2 - 220, y - 15, 440, 55);
      ctx.font = 'bold 20px monospace'; ctx.fillStyle = '#ffffff';
      ctx.fillText(opt.label, CANVAS_W / 2 - 200, y + 10);
      ctx.fillStyle = opt.valueColor || (sel ? '#00ff41' : '#888');
      const vw = ctx.measureText(opt.value).width;
      ctx.fillText(opt.value, CANVAS_W / 2 + 200 - vw, y + 10);
      if (sel) {
        ctx.font = '11px monospace'; ctx.fillStyle = '#666'; ctx.fillText(opt.hint, CANVAS_W / 2 - 200, y + 28);
        ctx.fillStyle = '#00ff41'; ctx.font = 'bold 20px monospace'; ctx.fillText('>', CANVAS_W / 2 - 215, y + 10);
      }
    });

    const descs = {
      easy: 'Slower zombies, shorter words, great for learning.',
      normal: 'Balanced speed and word difficulty.',
      hard: 'Faster zombies, longer words. For experienced typists.',
      extreme: 'Very fast, complex words. For 80+ WPM typists.',
      nightmare: 'Relentless speed, massive words. Built for 120+ WPM.'
    };
    ctx.font = '13px monospace'; ctx.fillStyle = cfg.color;
    const d = descs[this.difficulty]; ctx.fillText(d, CANVAS_W / 2 - ctx.measureText(d).width / 2, 470);

    if (this.rageMode) {
      ctx.font = '13px monospace'; ctx.fillStyle = '#ff6644';
      const rageDesc = `Rage: zombies accelerate to ${Math.round(cfg.rageMult * 100)}% speed as you type their word`;
      ctx.fillText(rageDesc, CANVAS_W / 2 - ctx.measureText(rageDesc).width / 2, 495);
    }

    ctx.font = '14px monospace'; ctx.fillStyle = '#555';
    ctx.fillText('Press ESC to return', CANVAS_W / 2 - 90, CANVAS_H - 30);
  }

  loop(timestamp) {
    if (this.lastTime === 0) this.lastTime = timestamp;
    const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05);
    this.lastTime = timestamp;
    this.update(dt); this.draw();
    requestAnimationFrame((t) => this.loop(t));
  }
}

window.addEventListener('load', () => { new Game(); });
})();
</script>
</body>
</html>
