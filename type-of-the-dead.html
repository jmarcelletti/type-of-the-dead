<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Type of the Dead</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: monospace;
  }
  #gameContainer {
    position: relative;
    border: 3px solid #00ff41;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
    border-radius: 8px;
    outline: none;
  }
  canvas { display: block; border-radius: 5px; }
</style>
</head>
<body>
<div id="gameContainer" tabindex="0">
  <canvas id="gameCanvas"></canvas>
</div>

<script>
// ============================================================
// TYPE OF THE DEAD - Browser-Based Typing Game
// Single standalone file - no dependencies
// ============================================================

(function() {
'use strict';

// --- Constants ---
const CANVAS_W = 900;
const CANVAS_H = 650;
const GROUND_Y = CANVAS_H - 100;
const PLAYER_X = CANVAS_W / 2;
const PLAYER_Y = CANVAS_H - 80;
const FPS = 60;
const FRAME_TIME = 1000 / FPS;

// --- Word Lists ---
const WORDS = {
  easy: [
    'cat','dog','run','jump','fast','slow','fire','dead','bite','dark',
    'bone','gore','fear','hand','head','kill','limb','moon','nail','pain',
    'rot','skin','tomb','vein','walk','yell','claw','doom','dusk','fade',
    'grim','howl','hunt','lurk','maul','ooze','prey','scar','wail','wake',
    'axe','bat','cry','dig','eat','fog','gut','hex','ink','jaw',
    'ash','ban','cap','den','elm','foe','gas','hog','ice','jab',
    'keg','lab','map','net','oak','pad','rag','sap','tar','urn'
  ],
  medium: [
    'zombie','typing','undead','blood','coffin','corpse','ghoul','grave',
    'horror','infect','killer','mortal','plague','scream','shadow','terror',
    'venom','wicked','attack','brain','crypt','decay','eerie','flesh',
    'haunt','impale','jungle','kidnap','legion','mayhem','nectar','occult',
    'python','quarry','ravage','savage','tangle','unholy','vandal','wraith',
    'ambush','blight','cackle','dagger','escape','fright','goblin','hunger',
    'impact','jackal','mortar','devour','fiend','mutant','sinister','demise'
  ],
  hard: [
    'apocalypse','resurrect','nightmare','graveyard','infection','slaughter',
    'decompose','monstrous','bloodbath','cannibal','cremation','disturbing',
    'exorcism','grotesque','headstone','labyrinth','mortician','nocturnal',
    'paranormal','quarantine','reanimated','sacrifice','tormented','underbelly',
    'vengeance','wasteland','adrenaline','barricade','contagion','damnation',
    'eliminate','fortified','guillotine','hallucinate','infestation',
    'juggernaut','kettledrum','laceration','malevolent','necromancer',
    'obliterate','pandemonium','relentless','suffocate','trepidation',
    'unforgiving','vulnerable','wanderlust','xenophobia','yellowjacket'
  ]
};

// --- Audio Engine (Web Audio API) ---
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.muted = false;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch(e) {
      console.warn('Web Audio API not available');
    }
  }

  playNote(freq, duration, type, volume) {
    if (!this.ctx || this.muted) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type || 'square';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(volume || 0.1, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }

  playNoise(duration, volume) {
    if (!this.ctx || this.muted) return;
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.max(0, 1 - i / bufferSize);
    }
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    const gain = this.ctx.createGain();
    gain.gain.value = volume || 0.15;
    source.connect(gain);
    gain.connect(this.ctx.destination);
    source.start();
  }

  gunshot() {
    this.playNoise(0.08, 0.2);
    this.playNote(150, 0.05, 'sawtooth', 0.15);
  }

  keystroke() {
    this.playNote(800 + Math.random() * 400, 0.04, 'square', 0.03);
  }

  zombieDeath() {
    this.playNoise(0.2, 0.15);
    this.playNote(200, 0.15, 'sawtooth', 0.08);
    this.playNote(100, 0.3, 'sawtooth', 0.06);
  }

  zombieHit() {
    this.playNoise(0.05, 0.1);
    this.playNote(300, 0.05, 'square', 0.05);
  }

  playerHit() {
    this.playNote(100, 0.3, 'sawtooth', 0.15);
    this.playNote(80, 0.4, 'square', 0.1);
  }

  waveComplete() {
    const notes = [523, 659, 784, 1047];
    notes.forEach((freq, i) => {
      setTimeout(() => this.playNote(freq, 0.2, 'square', 0.08), i * 100);
    });
  }

  gameOver() {
    const notes = [400, 350, 300, 200];
    notes.forEach((freq, i) => {
      setTimeout(() => this.playNote(freq, 0.4, 'sawtooth', 0.1), i * 200);
    });
  }

  menuSelect() {
    this.playNote(600, 0.08, 'square', 0.05);
    setTimeout(() => this.playNote(900, 0.08, 'square', 0.05), 50);
  }

  comboSound(combo) {
    const freq = 400 + Math.min(combo, 10) * 80;
    this.playNote(freq, 0.1, 'triangle', 0.06);
  }
}

// --- Particle System ---
class Particle {
  constructor(x, y, vx, vy, color, life, size) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.size = size || 3;
  }

  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.vy += 200 * dt; // gravity
    this.life -= dt;
  }

  draw(ctx) {
    const alpha = Math.max(0, this.life / this.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// --- Zombie Class ---
class Zombie {
  constructor(word, x, y, speed) {
    this.word = word.toUpperCase();
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.typed = 0; // number of letters typed
    this.alive = true;
    this.health = 1.0;
    this.targetX = PLAYER_X + (Math.random() - 0.5) * 100;
    this.targetY = PLAYER_Y;
    this.wobble = Math.random() * Math.PI * 2;
    this.wobbleSpeed = 1 + Math.random() * 2;
    this.radius = 25 + Math.random() * 8;
    this.flashTimer = 0;
    this.deathTimer = 0;
    this.dying = false;
  }

  update(dt) {
    if (this.dying) {
      this.deathTimer += dt;
      return this.deathTimer < 0.3;
    }

    this.wobble += this.wobbleSpeed * dt;
    const dx = this.targetX - this.x;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 1) {
      this.x += (dx / dist) * this.speed * dt + Math.sin(this.wobble) * 0.5;
      this.y += (dy / dist) * this.speed * dt;
    }

    if (this.flashTimer > 0) this.flashTimer -= dt;

    this.health = 1 - (this.typed / this.word.length);
    return true;
  }

  reachedPlayer() {
    return this.y >= GROUND_Y - 10 && !this.dying;
  }

  draw(ctx) {
    if (this.dying) {
      // Death animation - expand and fade
      const t = this.deathTimer / 0.3;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * (1 + t * 2), 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      return;
    }

    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(this.x, this.y + this.radius + 5, this.radius * 0.8, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = this.flashTimer > 0 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.4)';

    // Body
    const bodyColor = this.flashTimer > 0 ? '#ffffff' : (this.health < 0.4 ? '#8b0000' : '#cc3333');
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();

    // Inner body detail
    ctx.fillStyle = this.health < 0.4 ? '#660000' : '#aa2222';
    ctx.beginPath();
    ctx.arc(this.x + 3, this.y + 5, this.radius * 0.6, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    // Eyes
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(this.x - 8, this.y - 5, 5, 0, Math.PI * 2);
    ctx.arc(this.x + 8, this.y - 5, 5, 0, Math.PI * 2);
    ctx.fill();

    // Pupils
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(this.x - 7, this.y - 5, 2, 0, Math.PI * 2);
    ctx.arc(this.x + 9, this.y - 5, 2, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.x, this.y + 8, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();

    // Health bar
    const barW = 60;
    const barH = 6;
    const barX = this.x - barW / 2;
    const barY = this.y - this.radius - 35;
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, barH);
    const hpColor = this.health > 0.5 ? '#00ff00' : (this.health > 0.25 ? '#ffaa00' : '#ff4444');
    ctx.fillStyle = hpColor;
    ctx.fillRect(barX, barY, barW * this.health, barH);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barW, barH);

    // Word
    ctx.font = 'bold 22px monospace';
    const wordY = barY - 8;
    for (let i = 0; i < this.word.length; i++) {
      const ch = this.word[i];
      const totalWidth = ctx.measureText(this.word).width;
      const charX = this.x - totalWidth / 2 + ctx.measureText(this.word.substring(0, i)).width;

      ctx.lineWidth = 3;
      ctx.strokeStyle = '#000';
      ctx.strokeText(ch, charX, wordY);

      if (i < this.typed) {
        ctx.fillStyle = '#00ff41'; // typed letters in green
      } else if (this.typed > 0 && i === this.typed) {
        ctx.fillStyle = '#ffff00'; // next letter to type in yellow
      } else {
        ctx.fillStyle = '#ffffff';
      }
      ctx.fillText(ch, charX, wordY);
    }
  }
}

// --- Bullet Tracer ---
class Tracer {
  constructor(x1, y1, x2, y2) {
    this.x1 = x1; this.y1 = y1;
    this.x2 = x2; this.y2 = y2;
    this.life = 0.15;
  }

  update(dt) {
    this.life -= dt;
    return this.life > 0;
  }

  draw(ctx) {
    const alpha = this.life / 0.15;
    ctx.strokeStyle = `rgba(0, 255, 65, ${alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x1, this.y1);
    ctx.lineTo(this.x2, this.y2);
    ctx.stroke();
  }
}

// --- Muzzle Flash ---
class MuzzleFlash {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.life = 0.06;
  }

  update(dt) {
    this.life -= dt;
    return this.life > 0;
  }

  draw(ctx) {
    const alpha = this.life / 0.06;
    const size = 12 * alpha;
    ctx.fillStyle = `rgba(255, 255, 100, ${alpha * 0.8})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y - 15, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.5})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y - 15, size * 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- Main Game ---
class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.canvas.width = CANVAS_W;
    this.canvas.height = CANVAS_H;
    this.ctx = this.canvas.getContext('2d');
    this.container = document.getElementById('gameContainer');

    this.audio = new AudioEngine();
    this.state = 'menu'; // menu, playing, paused, gameover, highscores, options
    this.difficulty = 'normal'; // easy, normal, hard

    // Game objects
    this.zombies = [];
    this.particles = [];
    this.tracers = [];
    this.flashes = [];

    // Game state
    this.score = 0;
    this.wave = 0;
    this.lives = 3;
    this.combo = 0;
    this.maxCombo = 0;
    this.totalKills = 0;
    this.totalLettersTyped = 0;
    this.totalErrors = 0;
    this.currentInput = '';
    this.targetZombie = null;
    this.waveTimer = 0;
    this.waveDelay = 3;
    this.zombiesInWave = 0;
    this.zombiesSpawned = 0;
    this.spawnTimer = 0;
    this.waveComplete = false;
    this.waveAnnounceTimer = 0;
    this.screenShake = 0;
    this.screenShakeX = 0;
    this.screenShakeY = 0;

    // Menu state
    this.menuSelection = 0;
    this.menuItems = ['START GAME', 'HIGH SCORES', 'OPTIONS'];
    this.optionSelection = 0;

    // High scores
    this.highScores = this.loadHighScores();
    this.stats = this.loadStats();

    // Timing
    this.lastTime = 0;

    // Input
    this.setupInput();

    // Start loop
    requestAnimationFrame((t) => this.loop(t));
  }

  // --- Storage ---
  loadHighScores() {
    try {
      return JSON.parse(localStorage.getItem('totd_highscores')) || [];
    } catch { return []; }
  }

  saveHighScores() {
    try {
      localStorage.setItem('totd_highscores', JSON.stringify(this.highScores.slice(0, 10)));
    } catch {}
  }

  loadStats() {
    try {
      return JSON.parse(localStorage.getItem('totd_stats')) || { totalKills: 0, totalGames: 0, bestWave: 0, bestCombo: 0 };
    } catch { return { totalKills: 0, totalGames: 0, bestWave: 0, bestCombo: 0 }; }
  }

  saveStats() {
    try { localStorage.setItem('totd_stats', JSON.stringify(this.stats)); } catch {}
  }

  addHighScore(score, wave) {
    const entry = { score, wave, date: new Date().toLocaleDateString(), difficulty: this.difficulty };
    this.highScores.push(entry);
    this.highScores.sort((a, b) => b.score - a.score);
    this.highScores = this.highScores.slice(0, 10);
    this.saveHighScores();
    return this.highScores.indexOf(entry);
  }

  // --- Input ---
  setupInput() {
    this.container.addEventListener('keydown', (e) => {
      // Prevent browser defaults for game keys
      if (['Space', 'Escape', 'ArrowUp', 'ArrowDown', 'Enter', 'Tab'].includes(e.code)) {
        e.preventDefault();
      }

      this.audio.init();

      switch (this.state) {
        case 'menu': this.handleMenuInput(e); break;
        case 'playing': this.handleGameInput(e); break;
        case 'paused': this.handlePauseInput(e); break;
        case 'gameover': this.handleGameOverInput(e); break;
        case 'highscores': this.handleHighScoreInput(e); break;
        case 'options': this.handleOptionsInput(e); break;
      }
    });

    this.container.focus();
  }

  handleMenuInput(e) {
    if (e.code === 'ArrowUp') {
      this.menuSelection = (this.menuSelection - 1 + this.menuItems.length) % this.menuItems.length;
      this.audio.keystroke();
    } else if (e.code === 'ArrowDown') {
      this.menuSelection = (this.menuSelection + 1) % this.menuItems.length;
      this.audio.keystroke();
    } else if (e.code === 'Enter' || e.code === 'Space') {
      this.audio.menuSelect();
      if (this.menuSelection === 0) this.startGame();
      else if (this.menuSelection === 1) this.state = 'highscores';
      else if (this.menuSelection === 2) this.state = 'options';
    }
  }

  handleGameInput(e) {
    if (e.code === 'Escape') {
      this.state = 'paused';
      return;
    }

    if (e.code === 'Backspace') {
      if (this.currentInput.length > 0) {
        this.currentInput = this.currentInput.slice(0, -1);
        if (this.currentInput.length === 0) {
          if (this.targetZombie) this.targetZombie.typed = 0;
          this.targetZombie = null;
        } else if (this.targetZombie) {
          this.targetZombie.typed = this.currentInput.length;
        }
      }
      return;
    }

    // Only process single characters
    if (e.key.length !== 1) return;
    const ch = e.key.toUpperCase();
    if (!/[A-Z]/.test(ch)) return;

    this.audio.keystroke();
    this.totalLettersTyped++;
    const newInput = this.currentInput + ch;

    // If we have a target, check against it
    if (this.targetZombie && this.targetZombie.alive) {
      const nextChar = this.targetZombie.word[this.currentInput.length];
      if (ch === nextChar) {
        this.currentInput = newInput;
        this.targetZombie.typed = this.currentInput.length;
        this.targetZombie.flashTimer = 0.08;
        this.audio.zombieHit();

        // Fire tracer
        this.tracers.push(new Tracer(PLAYER_X, PLAYER_Y, this.targetZombie.x, this.targetZombie.y));
        this.flashes.push(new MuzzleFlash(PLAYER_X, PLAYER_Y));
        this.audio.gunshot();

        // Spawn hit particles
        for (let i = 0; i < 3; i++) {
          this.particles.push(new Particle(
            this.targetZombie.x, this.targetZombie.y,
            (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150,
            '#ff6644', 0.3 + Math.random() * 0.3, 3
          ));
        }

        // Check if zombie is dead
        if (this.currentInput.length === this.targetZombie.word.length) {
          this.killZombie(this.targetZombie);
          this.currentInput = '';
          this.targetZombie = null;
        }
      } else {
        // Wrong letter - error
        this.totalErrors++;
        this.combo = 0;
        this.screenShake = 0.1;
      }
    } else {
      // No target - find matching zombie
      const match = this.zombies.find(z => z.alive && !z.dying && z.word[0] === ch && z !== this.targetZombie);
      if (match) {
        this.targetZombie = match;
        this.currentInput = ch;
        match.typed = 1;
        match.flashTimer = 0.08;
        this.audio.zombieHit();
        this.tracers.push(new Tracer(PLAYER_X, PLAYER_Y, match.x, match.y));
        this.flashes.push(new MuzzleFlash(PLAYER_X, PLAYER_Y));
        this.audio.gunshot();

        for (let i = 0; i < 3; i++) {
          this.particles.push(new Particle(
            match.x, match.y,
            (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150,
            '#ff6644', 0.3, 3
          ));
        }

        if (match.word.length === 1) {
          this.killZombie(match);
          this.currentInput = '';
          this.targetZombie = null;
        }
      } else {
        this.totalErrors++;
        this.combo = 0;
      }
    }
  }

  handlePauseInput(e) {
    if (e.code === 'Escape' || e.code === 'Space') {
      this.state = 'playing';
    }
  }

  handleGameOverInput(e) {
    if (e.code === 'Space' || e.code === 'Enter') {
      this.audio.menuSelect();
      this.state = 'menu';
    }
  }

  handleHighScoreInput(e) {
    if (e.code === 'Escape' || e.code === 'Space' || e.code === 'Enter') {
      this.state = 'menu';
    }
  }

  handleOptionsInput(e) {
    if (e.code === 'Escape') {
      this.state = 'menu';
      return;
    }
    if (e.code === 'ArrowUp') {
      this.optionSelection = Math.max(0, this.optionSelection - 1);
      this.audio.keystroke();
    } else if (e.code === 'ArrowDown') {
      this.optionSelection = Math.min(1, this.optionSelection + 1);
      this.audio.keystroke();
    } else if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'Enter' || e.code === 'Space') {
      this.audio.menuSelect();
      if (this.optionSelection === 0) {
        // Cycle difficulty
        const diffs = ['easy', 'normal', 'hard'];
        const idx = diffs.indexOf(this.difficulty);
        this.difficulty = e.code === 'ArrowLeft'
          ? diffs[(idx - 1 + 3) % 3]
          : diffs[(idx + 1) % 3];
      } else if (this.optionSelection === 1) {
        this.audio.muted = !this.audio.muted;
      }
    }
  }

  // --- Game Logic ---
  startGame() {
    this.state = 'playing';
    this.score = 0;
    this.wave = 0;
    this.lives = 3;
    this.combo = 0;
    this.maxCombo = 0;
    this.totalKills = 0;
    this.totalLettersTyped = 0;
    this.totalErrors = 0;
    this.currentInput = '';
    this.targetZombie = null;
    this.zombies = [];
    this.particles = [];
    this.tracers = [];
    this.flashes = [];
    this.waveComplete = true;
    this.waveTimer = 1.5;
    this.screenShake = 0;
  }

  startWave() {
    this.wave++;
    this.waveComplete = false;
    this.waveAnnounceTimer = 2.0;

    const diffMult = this.difficulty === 'easy' ? 0.7 : (this.difficulty === 'hard' ? 1.4 : 1.0);
    this.zombiesInWave = Math.floor((3 + this.wave * 2) * diffMult);
    this.zombiesSpawned = 0;
    this.spawnTimer = 0;
    this.audio.waveComplete();
  }

  getWordForWave() {
    let pool;
    if (this.wave <= 2) {
      pool = WORDS.easy;
    } else if (this.wave <= 5) {
      pool = Math.random() < 0.6 ? WORDS.easy : WORDS.medium;
    } else if (this.wave <= 8) {
      pool = Math.random() < 0.3 ? WORDS.easy : (Math.random() < 0.6 ? WORDS.medium : WORDS.hard);
    } else {
      pool = Math.random() < 0.1 ? WORDS.easy : (Math.random() < 0.5 ? WORDS.medium : WORDS.hard);
    }

    // Avoid duplicate words on screen
    const activeWords = new Set(this.zombies.filter(z => z.alive).map(z => z.word));
    let word;
    let attempts = 0;
    do {
      word = pool[Math.floor(Math.random() * pool.length)].toUpperCase();
      attempts++;
    } while (activeWords.has(word) && attempts < 20);

    // Also avoid zombies starting with the same letter as another active zombie
    const activeFirstLetters = new Set(this.zombies.filter(z => z.alive && z.typed === 0).map(z => z.word[0]));
    if (activeFirstLetters.has(word[0]) && attempts < 40) {
      let retry = 0;
      while (activeFirstLetters.has(word[0]) && retry < 20) {
        word = pool[Math.floor(Math.random() * pool.length)].toUpperCase();
        retry++;
      }
    }

    return word;
  }

  spawnZombie() {
    const word = this.getWordForWave();
    const side = Math.random();
    let x, y;
    if (side < 0.6) {
      // Top
      x = 60 + Math.random() * (CANVAS_W - 120);
      y = -30;
    } else if (side < 0.8) {
      // Left
      x = -30;
      y = 50 + Math.random() * 200;
    } else {
      // Right
      x = CANVAS_W + 30;
      y = 50 + Math.random() * 200;
    }

    const diffMult = this.difficulty === 'easy' ? 0.6 : (this.difficulty === 'hard' ? 1.3 : 1.0);
    const baseSpeed = 20 + this.wave * 3 + Math.random() * 15;
    const speed = baseSpeed * diffMult;

    this.zombies.push(new Zombie(word, x, y, speed));
    this.zombiesSpawned++;
  }

  killZombie(zombie) {
    zombie.dying = true;
    zombie.deathTimer = 0;
    this.combo++;
    if (this.combo > this.maxCombo) this.maxCombo = this.combo;
    this.totalKills++;

    // Score: word length * 100 * combo multiplier
    const comboMult = Math.min(1 + (this.combo - 1) * 0.25, 5);
    const points = Math.floor(zombie.word.length * 100 * comboMult);
    this.score += points;

    // Screen shake
    this.screenShake = 0.15;

    // Death particles
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 200;
      this.particles.push(new Particle(
        zombie.x, zombie.y,
        Math.cos(angle) * speed, Math.sin(angle) * speed,
        Math.random() < 0.5 ? '#ff4444' : '#ff8844',
        0.5 + Math.random() * 0.5,
        2 + Math.random() * 4
      ));
    }

    this.audio.zombieDeath();
    this.audio.comboSound(this.combo);
  }

  damagePlayer() {
    this.lives--;
    this.combo = 0;
    this.screenShake = 0.3;
    this.audio.playerHit();

    // Red flash particles at bottom
    for (let i = 0; i < 20; i++) {
      this.particles.push(new Particle(
        PLAYER_X + (Math.random() - 0.5) * 100, PLAYER_Y,
        (Math.random() - 0.5) * 200, -Math.random() * 200,
        '#ff0000', 0.5 + Math.random() * 0.3, 4
      ));
    }

    if (this.lives <= 0) {
      this.endGame();
    }
  }

  endGame() {
    this.state = 'gameover';
    this.audio.gameOver();

    // Update stats
    this.stats.totalKills += this.totalKills;
    this.stats.totalGames++;
    if (this.wave > this.stats.bestWave) this.stats.bestWave = this.wave;
    if (this.maxCombo > this.stats.bestCombo) this.stats.bestCombo = this.maxCombo;
    this.saveStats();

    this.highScoreRank = this.addHighScore(this.score, this.wave);
  }

  // --- Update ---
  update(dt) {
    if (this.state !== 'playing') return;

    // Screen shake decay
    if (this.screenShake > 0) {
      this.screenShake -= dt;
      this.screenShakeX = (Math.random() - 0.5) * this.screenShake * 30;
      this.screenShakeY = (Math.random() - 0.5) * this.screenShake * 30;
    } else {
      this.screenShakeX = 0;
      this.screenShakeY = 0;
    }

    // Wave management
    if (this.waveComplete) {
      this.waveTimer -= dt;
      if (this.waveTimer <= 0) {
        this.startWave();
      }
      return;
    }

    // Wave announcement
    if (this.waveAnnounceTimer > 0) {
      this.waveAnnounceTimer -= dt;
    }

    // Spawn zombies
    if (this.zombiesSpawned < this.zombiesInWave) {
      this.spawnTimer -= dt;
      if (this.spawnTimer <= 0) {
        this.spawnZombie();
        const diffMult = this.difficulty === 'easy' ? 1.4 : (this.difficulty === 'hard' ? 0.6 : 1.0);
        this.spawnTimer = Math.max(0.5, (2.5 - this.wave * 0.15)) * diffMult;
      }
    }

    // Update zombies
    for (let i = this.zombies.length - 1; i >= 0; i--) {
      const z = this.zombies[i];
      const alive = z.update(dt);

      if (!alive) {
        // Remove dead zombie after death animation
        if (z === this.targetZombie) {
          this.targetZombie = null;
          this.currentInput = '';
        }
        this.zombies.splice(i, 1);
        continue;
      }

      // Check if zombie reached player
      if (z.reachedPlayer()) {
        if (z === this.targetZombie) {
          this.targetZombie = null;
          this.currentInput = '';
        }
        z.alive = false;
        this.zombies.splice(i, 1);
        this.damagePlayer();
      }
    }

    // Check wave complete
    if (this.zombiesSpawned >= this.zombiesInWave && this.zombies.filter(z => z.alive).length === 0) {
      this.waveComplete = true;
      this.waveTimer = 2.5;
      // Wave bonus
      this.score += this.wave * 200;
    }

    // Update particles
    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].update(dt);
      if (this.particles[i].life <= 0) this.particles.splice(i, 1);
    }

    // Update tracers
    for (let i = this.tracers.length - 1; i >= 0; i--) {
      if (!this.tracers[i].update(dt)) this.tracers.splice(i, 1);
    }

    // Update flashes
    for (let i = this.flashes.length - 1; i >= 0; i--) {
      if (!this.flashes[i].update(dt)) this.flashes.splice(i, 1);
    }
  }

  // --- Draw ---
  draw() {
    const ctx = this.ctx;
    ctx.save();

    // Apply screen shake
    if (this.state === 'playing' || this.state === 'gameover') {
      ctx.translate(this.screenShakeX, this.screenShakeY);
    }

    switch (this.state) {
      case 'menu': this.drawMenu(ctx); break;
      case 'playing':
      case 'paused':
        this.drawGameplay(ctx);
        if (this.state === 'paused') this.drawPause(ctx);
        break;
      case 'gameover': this.drawGameplay(ctx); this.drawGameOver(ctx); break;
      case 'highscores': this.drawHighScores(ctx); break;
      case 'options': this.drawOptions(ctx); break;
    }

    ctx.restore();
  }

  drawBackground(ctx) {
    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grad.addColorStop(0, '#0f0f1e');
    grad.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Stars
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    for (let i = 0; i < 50; i++) {
      // Use deterministic "random" based on index
      const sx = ((i * 137.5) % CANVAS_W);
      const sy = ((i * 73.1) % (GROUND_Y - 50));
      const size = ((i * 31.7) % 3) + 0.5;
      ctx.beginPath();
      ctx.arc(sx, sy, size, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ground
    ctx.fillStyle = '#16213e';
    ctx.fillRect(0, GROUND_Y, CANVAS_W, CANVAS_H - GROUND_Y);

    // Ground grid
    ctx.strokeStyle = '#0f3460';
    ctx.lineWidth = 1;
    for (let i = 0; i < CANVAS_W; i += 50) {
      ctx.beginPath();
      ctx.moveTo(i, GROUND_Y);
      ctx.lineTo(i + 25, CANVAS_H);
      ctx.stroke();
    }
    for (let y = GROUND_Y; y < CANVAS_H; y += 20) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(CANVAS_W, y);
      ctx.stroke();
    }
  }

  drawPlayer(ctx) {
    // Crosshair
    ctx.strokeStyle = '#00ff41';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(PLAYER_X - 20, PLAYER_Y);
    ctx.lineTo(PLAYER_X + 20, PLAYER_Y);
    ctx.moveTo(PLAYER_X, PLAYER_Y - 20);
    ctx.lineTo(PLAYER_X, PLAYER_Y + 20);
    ctx.stroke();

    ctx.fillStyle = '#00ff41';
    ctx.beginPath();
    ctx.arc(PLAYER_X, PLAYER_Y, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = '#00ff41';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(PLAYER_X, PLAYER_Y, 14, 0, Math.PI * 2);
    ctx.stroke();
  }

  drawHUD(ctx) {
    // Score box
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(10, 10, 220, 70);
    ctx.strokeStyle = '#00ff41';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, 220, 70);

    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = '#00ff41';
    ctx.fillText(`SCORE: ${this.score.toLocaleString()}`, 22, 35);
    ctx.fillText(`WAVE: ${this.wave}`, 22, 58);

    // Combo
    if (this.combo > 1) {
      ctx.fillStyle = '#ffaa00';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(`COMBO x${this.combo}`, 22, 77);
    }

    // Lives
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(CANVAS_W - 200, 10, 190, 40);
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 2;
    ctx.strokeRect(CANVAS_W - 200, 10, 190, 40);

    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = '#ff4444';
    let hearts = '';
    for (let i = 0; i < this.lives; i++) hearts += '\u2764 ';
    for (let i = this.lives; i < 3; i++) hearts += '\u2661 ';
    ctx.fillText(`LIVES: ${hearts}`, CANVAS_W - 188, 36);

    // Difficulty indicator
    ctx.font = '12px monospace';
    ctx.fillStyle = '#666';
    ctx.fillText(this.difficulty.toUpperCase(), CANVAS_W - 188, 62);

    // Input box
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(CANVAS_W / 2 - 160, CANVAS_H - 48, 320, 40);
    ctx.strokeStyle = this.targetZombie ? '#00ff41' : '#335533';
    ctx.lineWidth = 2;
    ctx.strokeRect(CANVAS_W / 2 - 160, CANVAS_H - 48, 320, 40);

    ctx.font = 'bold 22px monospace';
    ctx.fillStyle = '#00ff41';
    const displayText = this.currentInput || '';
    const cursor = (Date.now() % 1000 < 500) ? '_' : ' ';
    ctx.fillText(`> ${displayText}${cursor}`, CANVAS_W / 2 - 145, CANVAS_H - 22);
  }

  drawGameplay(ctx) {
    this.drawBackground(ctx);
    this.drawPlayer(ctx);

    // Draw tracers
    this.tracers.forEach(t => t.draw(ctx));

    // Draw flashes
    this.flashes.forEach(f => f.draw(ctx));

    // Draw zombies (sort by y for depth)
    const sortedZombies = [...this.zombies].sort((a, b) => a.y - b.y);
    sortedZombies.forEach(z => z.draw(ctx));

    // Draw particles
    this.particles.forEach(p => p.draw(ctx));

    // Target indicator
    if (this.targetZombie && this.targetZombie.alive && !this.targetZombie.dying) {
      ctx.strokeStyle = '#00ff41';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(this.targetZombie.x, this.targetZombie.y, this.targetZombie.radius + 10, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Wave announcement
    if (this.waveAnnounceTimer > 0) {
      const alpha = Math.min(1, this.waveAnnounceTimer / 0.5);
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 48px monospace';
      ctx.fillStyle = '#ff4444';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      const text = `WAVE ${this.wave}`;
      const tw = ctx.measureText(text).width;
      ctx.strokeText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 50);
      ctx.fillText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 50);

      ctx.font = '24px monospace';
      ctx.fillStyle = '#ffffff';
      const sub = `${this.zombiesInWave} zombies incoming`;
      const sw = ctx.measureText(sub).width;
      ctx.strokeText(sub, CANVAS_W / 2 - sw / 2, CANVAS_H / 2 - 10);
      ctx.fillText(sub, CANVAS_W / 2 - sw / 2, CANVAS_H / 2 - 10);
      ctx.globalAlpha = 1;
    }

    // Wave complete message
    if (this.waveComplete && this.wave > 0) {
      ctx.font = 'bold 32px monospace';
      ctx.fillStyle = '#00ff41';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      const text = 'WAVE COMPLETE!';
      const tw = ctx.measureText(text).width;
      ctx.strokeText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 30);
      ctx.fillText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 30);

      ctx.font = '20px monospace';
      ctx.fillStyle = '#ffaa00';
      const bonus = `Wave Bonus: +${this.wave * 200}`;
      const bw = ctx.measureText(bonus).width;
      ctx.strokeText(bonus, CANVAS_W / 2 - bw / 2, CANVAS_H / 2 + 10);
      ctx.fillText(bonus, CANVAS_W / 2 - bw / 2, CANVAS_H / 2 + 10);
    }

    this.drawHUD(ctx);
  }

  drawMenu(ctx) {
    this.drawBackground(ctx);

    // Ambient zombies in background
    ctx.globalAlpha = 0.15;
    for (let i = 0; i < 8; i++) {
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.arc(
        ((i * 137) % CANVAS_W),
        150 + ((i * 89) % 300),
        20 + (i % 3) * 5,
        0, Math.PI * 2
      );
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Title
    ctx.font = 'bold 56px monospace';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 6;
    const title = 'TYPE OF THE DEAD';
    const titleW = ctx.measureText(title).width;
    const titleX = CANVAS_W / 2 - titleW / 2;
    ctx.strokeText(title, titleX, 130);

    // Title with gradient
    const titleGrad = ctx.createLinearGradient(titleX, 80, titleX, 140);
    titleGrad.addColorStop(0, '#ff6666');
    titleGrad.addColorStop(1, '#cc0000');
    ctx.fillStyle = titleGrad;
    ctx.fillText(title, titleX, 130);

    // Title glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
    ctx.fillText(title, titleX, 130);
    ctx.shadowBlur = 0;

    // Subtitle
    ctx.font = 'italic 18px monospace';
    ctx.fillStyle = '#00ff41';
    const sub = 'Survive the zombie apocalypse with your keyboard';
    const subW = ctx.measureText(sub).width;
    ctx.fillText(sub, CANVAS_W / 2 - subW / 2, 170);

    // Menu items
    this.menuItems.forEach((item, i) => {
      const y = 260 + i * 80;
      const selected = i === this.menuSelection;

      ctx.fillStyle = selected ? 'rgba(255, 68, 68, 0.3)' : 'rgba(255, 68, 68, 0.1)';
      ctx.fillRect(CANVAS_W / 2 - 160, y, 320, 60);

      ctx.strokeStyle = selected ? '#ff4444' : '#662222';
      ctx.lineWidth = selected ? 3 : 1;
      ctx.strokeRect(CANVAS_W / 2 - 160, y, 320, 60);

      if (selected) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(255, 68, 68, 0.5)';
      }

      ctx.font = `bold 24px monospace`;
      ctx.fillStyle = selected ? '#ffffff' : '#888888';
      const iw = ctx.measureText(item).width;
      ctx.fillText(item, CANVAS_W / 2 - iw / 2, y + 38);
      ctx.shadowBlur = 0;

      if (selected) {
        ctx.fillStyle = '#ff4444';
        ctx.fillText('>', CANVAS_W / 2 - iw / 2 - 30, y + 38);
      }
    });

    // Controls hint
    ctx.font = '14px monospace';
    ctx.fillStyle = '#555';
    ctx.fillText('Arrow Keys to navigate | Enter to select', CANVAS_W / 2 - 180, CANVAS_H - 30);
  }

  drawPause(ctx) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    ctx.font = 'bold 48px monospace';
    ctx.fillStyle = '#00ff41';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    const text = 'PAUSED';
    const tw = ctx.measureText(text).width;
    ctx.strokeText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 20);
    ctx.fillText(text, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 20);

    ctx.font = '20px monospace';
    ctx.fillStyle = '#aaa';
    const hint = 'Press ESC or SPACE to resume';
    const hw = ctx.measureText(hint).width;
    ctx.fillText(hint, CANVAS_W / 2 - hw / 2, CANVAS_H / 2 + 30);
  }

  drawGameOver(ctx) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Game Over title
    ctx.font = 'bold 64px monospace';
    ctx.fillStyle = '#ff0000';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 5;
    const title = 'GAME OVER';
    const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 80);
    ctx.fillText(title, CANVAS_W / 2 - tw / 2, CANVAS_H / 2 - 80);

    // Stats
    ctx.font = 'bold 24px monospace';
    ctx.fillStyle = '#ffffff';
    const lines = [
      `Final Score: ${this.score.toLocaleString()}`,
      `Wave Reached: ${this.wave}`,
      `Zombies Killed: ${this.totalKills}`,
      `Max Combo: ${this.maxCombo}x`,
      `Accuracy: ${this.totalLettersTyped > 0 ? Math.round((1 - this.totalErrors / this.totalLettersTyped) * 100) : 0}%`
    ];

    lines.forEach((line, i) => {
      const lw = ctx.measureText(line).width;
      ctx.fillText(line, CANVAS_W / 2 - lw / 2, CANVAS_H / 2 - 20 + i * 35);
    });

    // High score indicator
    if (this.highScoreRank === 0) {
      ctx.font = 'bold 28px monospace';
      ctx.fillStyle = '#ffaa00';
      const hs = 'NEW HIGH SCORE!';
      const hsw = ctx.measureText(hs).width;
      ctx.fillText(hs, CANVAS_W / 2 - hsw / 2, CANVAS_H / 2 + 165);
    } else if (this.highScoreRank !== -1 && this.highScoreRank < 10) {
      ctx.font = '20px monospace';
      ctx.fillStyle = '#ffaa00';
      const hs = `Ranked #${this.highScoreRank + 1} on leaderboard!`;
      const hsw = ctx.measureText(hs).width;
      ctx.fillText(hs, CANVAS_W / 2 - hsw / 2, CANVAS_H / 2 + 165);
    }

    // Continue hint
    ctx.font = '18px monospace';
    ctx.fillStyle = '#666';
    const hint = 'Press SPACE to continue';
    const hw = ctx.measureText(hint).width;
    ctx.fillText(hint, CANVAS_W / 2 - hw / 2, CANVAS_H / 2 + 200);
  }

  drawHighScores(ctx) {
    this.drawBackground(ctx);

    ctx.font = 'bold 40px monospace';
    ctx.fillStyle = '#ff4444';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    const title = 'HIGH SCORES';
    const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, 70);
    ctx.fillText(title, CANVAS_W / 2 - tw / 2, 70);

    if (this.highScores.length === 0) {
      ctx.font = '20px monospace';
      ctx.fillStyle = '#666';
      ctx.fillText('No scores yet. Go kill some zombies!', CANVAS_W / 2 - 210, CANVAS_H / 2);
    } else {
      // Header
      ctx.font = 'bold 16px monospace';
      ctx.fillStyle = '#00ff41';
      ctx.fillText('RANK  SCORE         WAVE  DIFFICULTY  DATE', 120, 120);

      ctx.font = '16px monospace';
      this.highScores.forEach((entry, i) => {
        const y = 155 + i * 35;
        ctx.fillStyle = i === 0 ? '#ffaa00' : (i < 3 ? '#cccccc' : '#888888');
        const rank = `#${(i + 1).toString().padStart(2)}`;
        const score = entry.score.toLocaleString().padStart(12);
        const wave = entry.wave.toString().padStart(4);
        const diff = (entry.difficulty || 'normal').padStart(10);
        const date = entry.date || '';
        ctx.fillText(`${rank}  ${score}   ${wave}  ${diff}  ${date}`, 120, y);
      });
    }

    // Stats
    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = '#00ff41';
    ctx.fillText('CAREER STATS', 120, CANVAS_H - 130);
    ctx.font = '14px monospace';
    ctx.fillStyle = '#aaa';
    ctx.fillText(`Total Games: ${this.stats.totalGames}  |  Total Kills: ${this.stats.totalKills}  |  Best Wave: ${this.stats.bestWave}  |  Best Combo: ${this.stats.bestCombo}x`, 120, CANVAS_H - 100);

    ctx.font = '14px monospace';
    ctx.fillStyle = '#555';
    ctx.fillText('Press ESC or SPACE to return', CANVAS_W / 2 - 130, CANVAS_H - 30);
  }

  drawOptions(ctx) {
    this.drawBackground(ctx);

    ctx.font = 'bold 40px monospace';
    ctx.fillStyle = '#ff4444';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    const title = 'OPTIONS';
    const tw = ctx.measureText(title).width;
    ctx.strokeText(title, CANVAS_W / 2 - tw / 2, 100);
    ctx.fillText(title, CANVAS_W / 2 - tw / 2, 100);

    const options = [
      { label: 'Difficulty', value: this.difficulty.toUpperCase(), hint: 'Arrow Left/Right to change' },
      { label: 'Sound', value: this.audio.muted ? 'OFF' : 'ON', hint: 'Enter to toggle' },
    ];

    options.forEach((opt, i) => {
      const y = 220 + i * 100;
      const selected = i === this.optionSelection;

      ctx.fillStyle = selected ? 'rgba(0, 255, 65, 0.1)' : 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(CANVAS_W / 2 - 200, y - 20, 400, 60);
      ctx.strokeStyle = selected ? '#00ff41' : '#333';
      ctx.lineWidth = selected ? 2 : 1;
      ctx.strokeRect(CANVAS_W / 2 - 200, y - 20, 400, 60);

      ctx.font = 'bold 22px monospace';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(opt.label, CANVAS_W / 2 - 180, y + 8);

      ctx.fillStyle = selected ? '#00ff41' : '#888';
      const vw = ctx.measureText(opt.value).width;
      ctx.fillText(opt.value, CANVAS_W / 2 + 180 - vw, y + 8);

      if (selected) {
        ctx.font = '12px monospace';
        ctx.fillStyle = '#666';
        ctx.fillText(opt.hint, CANVAS_W / 2 - 180, y + 30);

        ctx.fillStyle = '#00ff41';
        ctx.fillText('>', CANVAS_W / 2 - 195, y + 8);
      }
    });

    ctx.font = '14px monospace';
    ctx.fillStyle = '#555';
    ctx.fillText('Press ESC to return', CANVAS_W / 2 - 90, CANVAS_H - 30);
  }

  // --- Game Loop ---
  loop(timestamp) {
    if (this.lastTime === 0) this.lastTime = timestamp;
    const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05); // cap delta
    this.lastTime = timestamp;

    this.update(dt);
    this.draw();

    requestAnimationFrame((t) => this.loop(t));
  }
}

// --- Start ---
window.addEventListener('load', () => {
  new Game();
});

})();
</script>
</body>
</html>
